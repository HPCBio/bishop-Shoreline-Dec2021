---
title: "Wilkens-Bishop Shoreline Project - Dec 2021 - Take 2"
author: "Chris Fields, Jessica Holmes"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    pdf_print: paged
    fig_height: 4
    fig_width: 6
    toc: yes
  word_document:
    toc: yes
    fig_height: 4
    fig_width: 6
  pdf_document:
    toc: yes
  powerpoint_presentation:
    toc: no
    fig_height: 4
    fig_width: 6
---

# Intro

This is the primary analysis file (including code) for a horse lung project using Shoreline's StrainID kit

# Set up

Code (not shown in the report) is initialized and loaded here.  We don't include the code in the report but make this available as needed; please see the [Github repository](https://github.com/HPCBio/bishop-Shoreline-2021-Dec) for this project for the final version.

Data from the primary project folder should be downloaded from [here](https://uofi.box.com/s/nsabc179j4aum0thtyav70d15jawo7p0) (requires permissions). Note the following assumes all data are in `2021-Dec-Shoreline`.

```{r, echo=TRUE, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r, include=FALSE}
# Note that not all libraries will be needed.  Most phyloseq code uses ggplot and tidyverse internally, therefore we explicitly load here
library(knitr)
library(tidyverse)
library(phyloseq)

# this seems to have issues with caching and phyloseq
# library(ggtree) 

# For normalization
library(metagenomeSeq)

# phylogenetic tree input
library(ape)

# read/modify BIOM 
library(biomformat)

# ggplot functions for trees and dendrograms
library(ggdendro)

# distance measures, PERMANOVA, ANOSIM
library(vegan)

# generation of stats values for graphs
library(ggpubr)

# normalization (CLR)
library(mixOmics)

# to get labels2color
library(WGCNA)

# mixed models (needs to be updated)
library(lme4)
library(lmerTest)
library(nlme)

# sample decontamination - didn't use
#library(decontam)

# to get post-hoc tests for mixed-model tests 
library(lsmeans)
library(devtools)

# needed in case we want to use ANCOM
#library(exactRankTests)

#Other libraries I added later
##library(BiocManager)
##BiocManager::install("microbiome")
##library(devtools)
##devtools::install_github("gauravsk/ranacapa")
##devtools::install_github("hpcbio/plotly_microbiome")
library(plotly.microbiome)
library(microbiome)
library(ranacapa)

# this is to load some extension helper code, see: https://github.com/HPCBio/phyloseq-extended
devtools::load_all('./phyloseq-extended/')
```

```{r, include=FALSE}
# Setting up the analysis, including adding helper functions.  The document won't include the actual code, but the functions are present in the Rmd document.  The functions here include ones to:
options(stringsAsFactors = FALSE)
theme_set(theme_bw())
```


```{r, include=FALSE}
# Remove the tags on the taxonomic ranks, which are redundant with the column headers.
stripTaxaTags <- function(physeq) {
  oldMA <- as(tax_table(physeq), "matrix")
  newMA <- apply(oldMA, 2, function(x) {sub('\\w__','', x)})
  if (inherits(physeq, "taxonomyTable")) {
      return(tax_table(newMA))
  }
  else {
      tax_table(physeq) <- tax_table(newMA)
      return(physeq)
  }
}
```

```{r }
# Convert sequences to names (culled from https://github.com/LangilleLab/microbiome_helper/blob/master/convert_dada2_out.R) 

renameTaxIds <- function(physeq, file.name="seqs.fasta") {
  suppressMessages(require("ShortRead"))
  seqtab.physeq <- otu_table(physeq)
  seqs <- colnames(seqtab.physeq)
  ids_study <- paste("seq", 1:ncol(seqtab.physeq), sep = "_")
  seqs.dna <- ShortRead(sread = DNAStringSet(seqs), id = BStringSet(ids_study))
  # Write out fasta file.
  writeFasta(seqs.dna, file = file.name)
  taxa_names(physeq) <- ids_study
  # TODO: add the sequences back to the phyloseq instance
  # physeq <- merge_phyloseq(physeq)
  return(physeq)
}
```

```{r}
# original code: https://github.com/twbattaglia/btools/blob/master/R/estimate_pd.R
estimate_pd <- function(phylo) {
  # Error if input is not of class phylo
  if(class(phylo) != "phyloseq"){
    stop("Input file is not of class 'phyloseq'.")
  }

  # Error if no class phy_tree
  if(!(.hasSlot(phylo, "phy_tree"))){
    stop("Could not find tree slot in phylo object.")
  }
  
  if (!require('picante')) stop("Function requires the picante library.")

  # Transpose if needed
  # Adapted from phyloseq/vegan import
  OTU <- phyloseq::otu_table(phylo)
  if (taxa_are_rows(OTU)) {
    OTU <- t(OTU)
  }

  # Get matrix version of OTU table
  otutable <- as(OTU, "matrix")

  # Get phylogenetic tree from phyloseq object
  tree <- phyloseq::phy_tree(phylo)

  # Print status message
  message("Calculating Faiths PD-index...")

  # If object is greater than 10mb, then print status message
  if(object.size(otutable) > 10000000){
    message("This is a large object, it may take awhile...")
  }

  # Calculate Faith's PD-index
  #
  pdtable <- picante::pd(otutable, tree, include.root = F)

  # Return data frame of results
  return(pdtable)
}
```

```{r}
# CLR normalization 
# (from McMurdie (Meth Mol Bio 2018) supplemental package)
zero_comp = function(x){
  if(taxa_are_rows(x)){x <- t(x)}
  matx = otu_table(x)
  # `zCompositions::cmultRepl` expects the samples to be in rows and OTUs to be in columns
  matxzc = zCompositions::cmultRepl(matx, method="CZM", output="p-counts")
  otu_table(x) <- otu_table(matxzc, taxa_are_rows = FALSE)
  return(x)
}
# CLR definition
geometric_mean = function(x){
  exp(mean(log(x)))
}
clr = function(x, base=2){
  x <- log((x / geometric_mean(x)), base)
}
phyloseq_CLR = function(physeq){
  suppressMessages({physeq <- zero_comp(physeq)})
  return(transform_sample_counts(physeq, fun = clr))
}
```

# Import and preprocessing

## Initial file input - PacBio

There is one PacBio run with all of the data.  Load it in along with the relevant tree and sequence data (metadata to be added).

First, let's load in the newer taxonomic analysis using QIIME2.  It looks like this:

```{r}
q2 <- readRDS('Phyloseq/tax_final.simple.RDS')
knitr::kable(head(q2))
```

```{r}
colnames(q2) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")
knitr::kable(head(q2))
```

```{r}
seqtab.tmp <- readRDS('Phyloseq/seqtab_final.simple.RDS')
tree.tmp <- read_tree('Plain/Trees/rooted.newick')
asvs.tmp <- Biostrings::readDNAStringSet('Plain/Sequences/asvs.simple.fna', format = 'fasta')
physeq.pacbio <- phyloseq(
  otu_table(seqtab.tmp, taxa_are_rows = F),
  tax_table(q2),
  asvs.tmp,
  tree.tmp)

physeq.pacbio
```

The sample names need to be cleaned up

```{r}
head(sample_names(physeq.pacbio))
```

<!-- Clean up the sample names -->

```{r}
tmp <- sample_names(physeq.pacbio)
tmp <- gsub('.filtered.*', '', tmp)
tmp
```

```{r}
sample_names(physeq.pacbio) <- tmp
sample_names(physeq.pacbio)
```

## Load metadata

Load in experimental data on samples (metadata).  Here are the first few rows:

```{r}
library(readxl)
tmp <- read_tsv('../reference/Bishop_sample_metadata.txt', comment = '#q2')
tmp$Well <- factor(tmp$Well)
tmp$Horse <- factor(tmp$Horse)
tmp$Sample_Type <- factor(tmp$Sample_Type)
tmp$Location <- factor(tmp$Location)
tmp$Sex<- factor(tmp$Sex)
tmp$Breed <- factor(tmp$Breed)

colnames(tmp)[1] <- "SampleID"

knitr::kable(head(tmp))
```

We also read in read QC so we can layer in whether read abundance plays a role.  We need to do a bit of our own read tracking here (it's not currently in the pipeline but can be added).

```{r results="asis"}
library(dada2)
getN <- function(x) sum(getUniques(x))

# the gsub here might be a bit brittle...
dadas <- as.data.frame(
    sapply(readRDS("dada2/dada2-Derep-Pooled/all.dds.RDS"), getN)
    )
rownames(dadas) <- gsub('.filtered.*','',rownames(dadas))
dadas$SampleID <- rownames(dadas)

seqtab.nochim <- as.data.frame(rowSums(readRDS("Phyloseq/seqtab_final.simple.RDS")))
rownames(seqtab.nochim) <- gsub('.filtered.fastq.*', '',rownames(seqtab.nochim))
seqtab.nochim$SampleID <- rownames(seqtab.nochim)

trimmed <- read.csv("dada2/dada2-FilterAndTrim/all.trimmed.csv")
rownames(trimmed) <- gsub('.fastq.*', '',trimmed$Sequence)
trimmed$SampleID <- rownames(trimmed)

track <- Reduce(function(...) merge(..., by = "SampleID",  all.x=TRUE),  list(trimmed, dadas, seqtab.nochim))
# dropped data in later steps gets converted to NA on the join
# these are effectively 0
track[is.na(track)] <- 0

colnames(track) <- c("SampleID", "Sequence", "input", "filtered", "denoised", "nonchim")
write.table(track, "all.readtracking.txt", sep = "\t", row.names = FALSE)
knitr::kable(head(track))
```

It appears that no filtering step had too large of a drop, so this is reassuring.

Now combine all metadata together for analysis and add back to the class.

```{r}
#Combine metadata
tmp2 <- sample_data(right_join(tmp, track, by="SampleID"))
sample_names(tmp2) <- tmp2$SampleID
sample_names(tmp2)
```

```{r}
sample_data(physeq.pacbio) <- tmp2
physeq.pacbio
```

What do the first rows look like?

```{r results="asis"}
sample_data(physeq.pacbio) %>% as("data.frame") %>% head %>% knitr::kable()
```

# Raw composition plots

Overall compositional summary (stacked bar plots) for samples.  In this example here are the top 15 families by composition per sample, split by treatment.

```{r }
#Phyloseq bar plot
p <- plot_bar(physeq.pacbio, x="SampleID", fill="Class")
p

# Old code below that isn't working.
#p <- phyloseq.extended::plot_composition(physeq.pacbio, 
#                                         taxaSet1 = NULL, 
#                                         taxaRank2 = "Genus", 
#                                         fill = "Family", 
#                                         numberOfTaxa = 15)
#p + facet_wrap(~Treatment, scales = "free_x", nrow = 1)
```

There is an abnormally huge amount of diversity present in the raw composition plots. Hopefully this is reduced after filtering.


```{r}
table(tax_table(physeq.pacbio)[,'Domain'])
```

Everything is classified as Bacteria, except for 4 archae and 4 Unclassified.


# Sample and Taxa Filtering

The steps below are standard filtering steps that will differ per analysis. 

## Focus on only experimental samples 

In this analysis we are considering all of the data and don't subset anything.  Any sample-specific quality issues that need filtering are addressed as outliers below.

## Removing artifacts

We do need to remove ASVs that are likely artifactual, for example from host, and that we want to remove.  We should get rid of:

* Unranked/unassigned
* Eukarya (kingdom)
* Mitochondria
* Chloroplast

The RDP classifier will misclassify sequences that have very little sequence similarity to 16S based on the way it works; these tend to classify poorly by rank (NA or 'Unclassified' up to and sometimes including Domain/Kingdom).  

What proportion of the ASVs are unassigned at each rank?

```{r}
taxtab <- tax_table(physeq.pacbio)

library(scales)

# note this test checks if the rank is NA; if the rank is assigned 'Unclassified' modify the term here
ranks <- data.frame(apply(taxtab, 2, 
                          function(x) label_percent(accuracy = 0.01) (sum( x == 'Unclassified' )/length(x) ) ))
colnames(ranks) <- c("Perc.Unclassified")
ranks %>% kable
```

First analysis: Classification looks pretty good. Almost everything is classified up to the "Order" level.
Current analysis: Classification isn't as good, but it is decent.

How many are unclassified at Domain level?

```{r }
table(tax_table(physeq.pacbio)[,'Domain']) %>% kable
```

Four

```{r}
unasn <- subset_taxa(physeq.pacbio, Domain == "Unclassified")
unasn
```


```{r}
dir.create(file.path('..', 'results', 'sequences'), showWarnings = FALSE, recursive = TRUE)
writeXStringSet(refseq(unasn), 
                filepath = '../results/sequences/unassigned.fna', 
                format = 'fasta')
```

Subset those sequences that have assignments at least at the Phylum level.

```{r }
physeq.pacbio <- subset_taxa(physeq.pacbio, !(Phylum == 'Unclassified'))
physeq.pacbio
```

### Eukaryotic sequences

None were found that were explicitly classified as eukarya, so skipping.

<!-- ```{r } -->
<!-- # extract eukaryotic sequences if found -->
<!-- euks <- subset_taxa(physeq.pacbio, Domain == "Eukaryota") -->
<!-- tax_table(euks) %>% as.data.frame %>% knitr::kable() -->
<!-- ``` -->

<!-- ```{r } -->
<!-- tmp <- sample_sums(euks) -->
<!-- tmp[ tmp > 0 ] -->
<!-- ``` -->

<!-- ```{r } -->
<!-- physeq.pacbio <- subset_taxa(physeq.pacbio, !(Domain == 'Eukaryota')) -->
<!-- ``` -->

### Organelle 16S (mitochondria, chloroplast)

Next we check for organelle 16S.  These could arise in chloroplast or mitochondria.  They are classified under different rank criteria in Silva, so we need to check for them separately. 

Any hits for chloroplast? These are found under the `Order` rank.

```{r }
table(tax_table(physeq.pacbio)[,'Order'])['Chloroplast']
```

2 chloroplast sequences.  Let's grab these and export to look into further; these are the samples that have chloroplast sequences. 

```{r}
chloros <- subset_taxa(physeq.pacbio, Order == 'Chloroplast')
sample_sums(chloros) %>% magrittr::extract(. > 0)
```


Any mitochondrial sequences?  

```{r }
table(tax_table(physeq.pacbio)[,'Family'])['Mitochondria']
```

65 are found. (None were found in 1st analysis, so this is surprising)

```{r }
 mitos <- subset_taxa(physeq.pacbio, Family == 'Mitochondria')
 sample_sums(mitos) %>% magrittr::extract(. > 0)
```


For the final filtered data, we will remove the chloroplast and mitochondria taxa.

```{r }
# remove control samples that aren't part of the analysis (water, Zymo)
# physeq.filtered <- subset_samples(physeq.pacbio, Treatment != 'Control')

# remove mitochondria
 physeq.filtered <- subset_taxa(physeq.pacbio, Family != 'Mitochondria')

# remove chloroplast
physeq.filtered <- subset_taxa(physeq.filtered, Order != 'Chloroplast')

physeq.filtered
```

## Remove taxa with 0 counts

Do we need to filter out any taxa with 0 counts?  Let's check how many have taxonomic sums equal to 0

```{r }
table(taxa_sums(physeq.filtered) == 0)
```

There are no taxa with 0 counts. So skipping the following.


```{r }
#physeq.filtered <- prune_taxa(taxa_sums(physeq.filtered) > 0, physeq.filtered)
#physeq.filtered
```

How about the number of samples who have 0 counts?

```{r }
table(sample_sums(physeq.filtered) == 0)
```

No samples with zero counts after filtering in the above steps. No filtering needed.

```{r }
# sample_data(physeq)[sample_sums(physeq.filtered) == 0]
```


```{r }
# physeq.filtered <- prune_samples(sample_sums(physeq.filtered) > 0, physeq)
# physeq.filtered
```

## Other contaminants?

We won't run this yet but we can remove biological contaminants here. 

```{r }
# These steps use the decontam library

# df.contam <- as.data.frame(sample_data(physeq.filtered))
# df.contam$LibrarySize <- sample_sums(physeq.filtered)

# sample_data(physeq.filtered)$is.neg <- sample_data(physeq.filtered)$Control == "Negative"
# contamdf.prev <- isContaminant(physeq.filtered, 
#                                method = "prevalence", 
#                                neg = "is.neg", 
#                                threshold = 0.1)
# 
# table(contamdf.prev$contaminant)
```

<!-- Which ones are contaminants? -->

```{r }
# which(contamdf.prev$contaminant)
```

<!-- Based on the threshold we are seeing some contaminants showing up; how prevalent are they in the overall samples? -->

```{r }
# ps.neg <- prune_samples(
#   sample_data(physeq.filtered)$Control == "Negative", physeq.filtered)
# ps.neg.presence <- transform_sample_counts(ps.neg, function(abund) 1*(abund > 0))
# 
# ps.pos <- prune_samples(
#   sample_data(physeq.filtered)$Control == "Sample", physeq.filtered)
# ps.pos.presence <- transform_sample_counts(ps.pos, function(abund) 1*(abund > 0))
# 
# df.pres <- data.frame(
#   prevalence.pos = taxa_sums(ps.pos.presence), 
#   prevalence.neg = taxa_sums(ps.neg.presence),
#   contam.prev = contamdf.prev$contaminant)
# 
# ggplot(data = df.pres, aes(x=prevalence.neg, y=prevalence.pos, color=contam.prev)) + 
#   geom_point()
```

```{r }
# physeq.filtered <- prune_taxa(!contamdf.prev$contaminant, physeq.filtered)
# physeq.filtered
```

## Prune low count samples

Before removing samples, we can see the spread of counts per sample here.

```{r}
hist(sample_sums(physeq.filtered), breaks = 50)
```

Which are less than 50 sequences?

```{r}
lowcount <- subset_samples(physeq.filtered, sample_sums(physeq.filtered) < 50)
sample_sums(lowcount) %>% magrittr::extract(. < 50)
```

## Prune out samples

Removing the three samples identified above (this is one more than the first analysis)

```{r }
physeq.filtered <- prune_samples(sample_sums(physeq.filtered) > 50, physeq.filtered)
physeq.filtered
```

# Basic overview

Let's look at the data.  We have `r ntaxa(physeq.filtered)` taxa and `r nsamples(physeq.filtered)` samples.

Before plotting, let's change the order of metadata.

```{r}
#Rearrange location order
sample_data(physeq.filtered)$Location <- factor(sample_data(physeq.filtered)$Location,levels = c("NPL","TTA","LD","LCd","LCr","RD","RCd","RCr"))
sample_data(physeq.filtered)$Location
sample_data(physeq.filtered)$Sample_Type <- factor(sample_data(physeq.filtered)$Sample_Type,levels = c("NPL","TTA","BAL"))
sample_data(physeq.filtered)$Sample_Type
```

Here are the sample variables for analysis:

```{r }
sample_variables(physeq.filtered)
```

Note these include data from read tracking.  Here is a simple summary of the phylogenetic tree (this is midpoint-rooted in the workflow) with the top 50 most abundant ASVs.

```{r }
# get the top 50 taxa based on overall taxa sums
myTaxa1 <- names(sort(taxa_sums(physeq.filtered), decreasing = TRUE))[1:50]

# generate a tmp instance with only those taxa
ex0 = prune_taxa(myTaxa1, physeq.filtered)

# plot with only those, labeling as needed
plot_tree(ex0, label.tips = 'Genus',
          ladderize = "left",
          justify = "left",
          color = 'Location'
          )
```

# Alpha rarefaction

Let's check whether we're adequately capturing diversity.  This is a simple alpha rarefaction curve; here we want to see the number of taxa plateau as the counts increase.

```{r, include=FALSE}
p <- suppressMessages(ranacapa::ggrare(physeq.filtered, step = 50,
            color = "Location",
         #   label = "SampleID",
            se = FALSE,
            plot = FALSE,
            ))
```

```{r}
p + ggtitle("Alpha Rarefaction") + coord_cartesian(xlim=c(0,150000), ylim=c(0,200))
```

1st analysis: No obvious trends between location of samples. For most samples, it appears as though all the diversity is captured, with the exception of RMB_VIN_BAL_RCr and the 4 samples with less than 5000 sequences. In addition, RMB_VIN_NPL, has an abnormally high alpha diversity score compared to the rest of the samples.
Current analysis: all lines plateau for all samples very quickly. Species richness seems to be lower than the 1st analysis. RMB_AMB_BAL_LCd has the highest species diversity.


```{r}
p <- p + ggtitle("Alpha Rarefaction by Location") + coord_cartesian(xlim=c(0,125000), ylim=c(0,200)) + facet_wrap(~Location) 

p
#ggsave("alpha-rarefaction-byLocation.pdf", path = "results/final-plots", device = pdf, width = 7.5, height = 5, units = "in")
```

# Composition plots on filtered data

Here we will post a few plots for an overall compositional summary (stacked bar plots).  In this example here are the top 15 families by composition per sample, split by treatment. 

```{r }
#Phyloseq bar plot
p <- plot_bar(physeq.pacbio, x="SampleID", fill="Class")
p + theme(legend.key.size = unit(0.25, 'cm'), #change legend key size
        legend.title = element_text(size=8), #change legend title font size
        legend.text = element_text(size=8),
        axis.text.x = element_blank()) +
        facet_wrap(~Location, scales = "free_x")

# Old code
#p <- phyloseq.extended::plot_composition(physeq.filtered, 
#                                         taxaSet1 = NULL, 
#                                         taxaRank2 = "Family", 
#                                         fill = "Family", 
#                                         numberOfTaxa = 15)
#p + facet_wrap(~Location, scales = "free_x", nrow = 1)
```

It's hard to tell by eye, since there are so many species

```{r}
#p + facet_wrap(~Tissue, scales = "free_x", nrow = 1)
```

# Alpha diversity

Check alpha diversity stats.  Note we haven't performed any additional filtering or agglomeration at this stage; this is largely due to recommendations to prevent loss of rare ASVs or singletons in the data, which can dramatically affect alpha diversity measures.  Specifically (from the `plot_richness` function used here):

> You must use untrimmed, non-normalized count data for meaningful results, as many of these estimates are highly dependent on the number of singletons. You can always trim the data later on if needed, just not before using this function.

## Overall

```{r}
# all six measures: Observed, Chao1, ACE, Shannon, Simpson, Inv. Simpson, Fisher
erDF <- estimate_richness(physeq.filtered, measures = c("Observed", "Chao1", "ACE", "Shannon", "Simpson", "InvSimpson"))

# add Faith's PD, this is a simple wrapper to format everything correctly
pd <- estimate_pd(physeq.filtered)

# we don't need SR, it's the same as observed
erDF$PD <- pd$PD

measures <- colnames(erDF)
```
NOTE: There was a warning that Fisher results could not be trusted and were unable to be calculated, so I removed them from the analysis. I also got a warning that my data lacked singletons, but I have not filtered for abundance yet like it suggests may have happened, so I will ignore this warning.


We'll check the overall measures for alpha diversity across different groups.  The descriptions below are largely from the [QIIME2 forum](https://forum.qiime2.org/t/alpha-and-beta-diversity-explanations-and-commands/2282) with some additional notes.

* **Observed** - Number of features (ASVs in this case).  From the `phyloseq` package, function `estimate_richness`. 
* **Chao1** - Estimates number of rare taxa missed from undersampling, with an associated confidence interval. Compare to observed taxa, the difference will be those expected to be missing. From the `phyloseq` package, function `estimate_richness`. 
* **ACE** - Abundance-based Coverage Estimator. Estimates species richness using a correction factor.  From the `phyloseq` package, function `estimate_richness`. 
* **Shannon** - Calculates richness and diversity using a natural logarithm, accounts for both abundance and evenness of the taxa present. From the `vegan` package, function `diversity`. 
* **Simpson** - Measures the relative abundance of the different species making up the sample richness.  From the `vegan` package, function `diversity`. 
* **Inverse Simpson** - Measures the relative abundance of the different species making up the sample richness.  From the `vegan` package, function `diversity`. 
* **Fisher** - Relationship between the number of species and the abundance of each species.  From the `vegan` package, function `diversity`. 
* **Faith's PD** - Sum of the total phylogenetic branch length for one or multiple samples.  From the `picante` package, function `pd`. 

```{r}
# this is a modification of the plot_richness function from phyloseq, but takes as input a pre-generated matrix of estimates from `estimate_richness` or any other function, plus the phyloseq instance.  
plot_richness_estimates = function(physeq, 
                                   erDF, 
                                   x="samples", 
                                   color=NULL, 
                                   shape=NULL, 
                                   title=NULL,
                                   scales="free_y", 
                                   nrow=1, 
                                   sortby=NULL) {
  # TODO: add sanity check on matrix (e.g. rows == sample IDs, sample names, and column names)
  
  # Measures may have been renamed in `erDF`. Replace it with the name from erDF
  measures = colnames(erDF)
  # Define "measure" variables and s.e. labels, for melting.
  ses = colnames(erDF)[grep("^se\\.", colnames(erDF))]
  # Remove any S.E. from `measures`
  measures = measures[!measures %in% ses]
	# Make the plotting data.frame.
  # This coerces to data.frame, required for reliable output from reshape2::melt()
  if( !is.null(sample_data(physeq, errorIfNULL=FALSE)) ){
    # Include the sample data, if it is there.
	  DF <- data.frame(erDF, sample_data(physeq))
  } else {
    # If no sample data, leave it out.
    DF <- data.frame(erDF)
  }
	if( !"samples" %in% colnames(DF) ){
	  # If there is no "samples" variable in DF, add it
		DF$samples <- sample_names(physeq)
	}
	# sample_names used to be default, and should also work.
	# #backwardcompatibility
	if( !is.null(x) ){
		if( x %in% c("sample", "samples", "sample_names", "sample.names") ){
			x <- "samples"
		}
	} else {
    # If x was NULL for some reason, set it to "samples"
	  x <- "samples"
	}
	# melt to display different alpha-measures separately
	mdf = reshape2::melt(DF, measure.vars=measures)
  # Initialize the se column. Helpful even if not used.
  mdf$se <- NA_integer_
  if( length(ses) > 0 ){
    ## Merge s.e. into one "se" column
    # Define conversion vector, `selabs`
    selabs = ses
    # Trim the "se." from the names
    names(selabs) <- substr(selabs, 4, 100)
    # Make first letter of selabs' names uppercase
    substr(names(selabs), 1, 1) <- toupper(substr(names(selabs), 1, 1))
    # use selabs conversion vector to process `mdf`
    mdf$wse <- sapply(as.character(mdf$variable), function(i, selabs){selabs[i]}, selabs)
    for( i in 1:nrow(mdf) ){
      if( !is.na(mdf[i, "wse"]) ){
        mdf[i, "se"] <- mdf[i, (mdf[i, "wse"])]
      }
    }
    # prune the redundant columns
    mdf <- mdf[, -which(colnames(mdf) %in% c(selabs, "wse"))]
  }
  ## Interpret measures
  # If not provided (default), keep all 
  if( !is.null(measures) ){
    if( any(measures %in% as.character(mdf$variable)) ){
      # If any measures were in mdf, then subset to just those.
      mdf <- mdf[as.character(mdf$variable) %in% measures, ]
    } else {
      # Else, print warning about bad option choice for measures, keeping all.
      warning("Argument to `measures` not supported. All alpha-diversity measures (should be) included in plot.")
    }
  }
  # Address `sortby` argument
  if(!is.null(sortby)){
    if(!all(sortby %in% levels(mdf$variable))){
      warning("`sortby` argument not among `measures`. Ignored.")
    }
    if(!is.discrete(mdf[, x])){
      warning("`sortby` argument provided, but `x` not a discrete variable. `sortby` is ignored.")
    }
    if(all(sortby %in% levels(mdf$variable)) & is.discrete(mdf[, x])){
      # Replace x-factor with same factor that has levels re-ordered according to `sortby`
      wh.sortby = which(mdf$variable %in% sortby)
      mdf[, x] <- factor(mdf[, x],
                         levels = names(sort(tapply(X = mdf[wh.sortby, "value"],
                                                    INDEX = mdf[wh.sortby, x],
                                                    mean,
                                                    na.rm=TRUE, simplify = TRUE))))
    }
  }
  # Define variable mapping
  richness_map = aes_string(x=x, y="value", colour=color, shape=shape)
  # Make the ggplot.
  p = ggplot(mdf, richness_map) + geom_point(na.rm=TRUE)  
  # Add error bars if mdf$se is not all NA
  if( any(!is.na(mdf[, "se"])) ){
    p = p + geom_errorbar(aes(ymax=value + se, ymin=value - se), width=0.1) 
  }
  # Rotate horizontal axis labels, and adjust
	p = p + theme(axis.text.x=element_text(angle=-90, vjust=0.5, hjust=0))
	# Add y-label 
	p = p + ylab('Alpha Diversity Measure') 
  # Facet wrap using user-options
	p = p + facet_wrap(~variable, nrow=nrow, scales=scales)
	# Optionally add a title to the plot
	if( !is.null(title) ){
		p <- p + ggtitle(title)
	}
	return(p)
}

```

```{r}
sample_data(physeq.filtered)$Simple_Type <- sample_data(physeq.filtered)$Sample_Type
levels(sample_data(physeq.filtered)$Simple_Type) <- c("NPL-TTA","NPL-TTA","BAL")
```

```{r}
p <- plot_richness_estimates(physeq = physeq.filtered, 
                             erDF = erDF, # PD
                             "Simple_Type", 
                             color = "Simple_Type", 
                             title="Alpha diversity in different treatment groups")

p + geom_boxplot(aes(x=Simple_Type, 
                     y=value,
                     color=NULL), alpha=0.1) +
  stat_compare_means(label = "p.signif",
                     ref.group = "BAL",
                     hide.ns = TRUE,
                     method = "wilcox.test") +
  ylab("Faith PD") + 
  #scale_x_discrete(labels=labels) + 
  theme(legend.position = "none")

ggsave("all-alpha-metrics-bySimpleType.pdf", path = "results/alpha-and-taxa-plots/", device = "pdf", width = 7, height = 5, units = "in")
```
Nothing is significant for PD


All alpha diversity metrics by Location:
```{r}
p <- plot_richness_estimates(physeq = physeq.filtered, 
                             erDF = erDF, # all metrics
                             "Location", 
                             color = "Location", 
                             title="Alpha diversity in different treatment groups")

p + geom_boxplot(aes(x=Location, 
                     y=value, 
                     color=NULL), alpha=0.1) +
  stat_compare_means(label = "p.signif",
                     ref.group = 'NPL',
                     method = "wilcox.test",
                     hide.ns = TRUE) +
  ylab("Alpha diversity score") + 
  #scale_x_discrete(labels=labels) + 
  theme(legend.position = "none")

ggsave("alpha-ALLmetrics-byLocation.pdf", path = "../results/final-plots", device = "pdf", width = 10, height = 5, units = "in")
```
No significance across any of the metrics when compared to NPL. I'm not sure what the proper control would be in this case, if any, but I also tried comparing to TTA and there was no significance.

All alpha diversity metrics by Sample_Type:
```{r}
p <- plot_richness_estimates(physeq = physeq.filtered, 
                             erDF = erDF, # all metrics
                             "Sample_Type", 
                             color = "Sample_Type", 
                             title="Alpha diversity in different treatment groups")

p + geom_boxplot(aes(x=Sample_Type, 
                     y=value, 
                     color=NULL), alpha=0.1) +
  stat_compare_means(label = "p.signif",
                     ref.group = 'NPL',
                     method = "wilcox.test",
                     hide.ns = TRUE) +
  ylab("Alpha diversity score") + 
  #scale_x_discrete(labels=labels) + 
  theme(legend.position = "none")

#ggsave("alpha-ALLmetrics-bySample_Type.pdf", path = "results/final-plots", device = "pdf", width = 10, height = 5, units = "in")
```
1st analysis: For Faith_PD only, BAL is significant when NPL is the reference.
Current analysis: nothing is significant


## Check for normal distribution 

### Plot to check normality

Do these look like a normal distribution?

```{r }
library(scales)
par(mfrow = c(2, 3))

lapply(c('Chao1', 'Shannon', 'Simpson', 'InvSimpson', 'Observed', 'PD'), 
       function(x) {
         shap <- shapiro.test(erDF[,x])
         hist(erDF[,x], xlab = "Measure", main=paste0(x, "\nShapiro pvalue=", label_number(accuracy = 0.0001)(shap$p.value)), breaks=15)
         })
```

All of these except for Shannon, look skewed and do not pass the Shapiro-Wilk test for normality. This means, we should be using non-parametric tests. The Wilcoxen Rank sum test used above, is non-parametric.

# Save point
```{r }
saveRDS(physeq.filtered, file = "results/phyloseq.filtered.pt1.RDS")
```

# Filtering

NOTE: The PrevalenceFiltering.Rmd script was run at this point.

## Load Prevalence filtering results.

```{r}
physeq.prev <- readRDS("./results/PrevalenceFiltering/phyloseq.prevfiltered.RDS")
```

# Basic composition plot on agglomerated data

```{r }
p <- plot_bar(physeq.prev, x="Horse", fill="Order")
p + theme(legend.key.size = unit(0.2, 'cm'), #change legend key size
        legend.title = element_text(size=8), #change legend title font size
        legend.text = element_text(size=8, face="italic")) +
  facet_wrap(~Location, scales = "free_x")

ggsave("filtered-taxonomy-bar-plot_Order-level_byLocation.pdf",path="./results/alpha-and-taxa-plots//", height = 8, width = 8, device="pdf")

#p <- phyloseq.extended::plot_composition(physeq.prev,
#                      numberOfTaxa = 15,
#                      taxaSet1 = NULL,
#                      fill = "Family",
#                      x = "SampleID")
#p1 <- p + facet_wrap(~Treatment, scales = "free_x", nrow = 1)
#p1
```


# Relative abundance tables

```{r }
p <- plot_bar(physeq.test, x="SampleID", fill="Family")
p + theme(legend.key.size = unit(0.2, 'cm'), #change legend key size
        legend.title = element_text(size=8), #change legend title font size
        legend.text = element_text(size=8, face="italic")) +
  facet_wrap(~Simple_Type, scales = "free_x")

ggsave("relative-abund-taxonomy-bar-plot_Family-level_bySimpleType.pdf",path="./results/alpha-and-taxa-plots/", height = 8, width = 8, device="pdf")
```

# Beta diversity

Initial beta diversity calculation. Bray Curtis metric used for calculating compositional/beta diversity scores, and NMDS ordination used for ordering samples and taxa. These settings are generally recommended for microbial datasets that include many null values. 

```{r }
p <- plot_heatmap(physeq.prev,
                  method = "NMDS",
                  distance = "bray",
                  taxa.label = "Family",
                  sample.label = "Location",
                  trans = log_trans(2))
p
```
1st analysis: The NPL samples naturally group somewhat well together, but no other obvious groupings.
Current analysis: Groupings seem mostly random. 


## Relative proportion

Transform data to relative proportions (no prior added).  We may want the option to change this later.

```{r }
#All samples
physeq.prop <- transform_sample_counts(physeq.prev, function(x) x/sum(x) )
sample_data(physeq.prop)$SampleSums <- sample_sums(physeq.prev)
```

## CLR normalization, McMurdie

Transform data using CLR (from McMurdie (Meth Mol Bio 2018) supplemental package).  

```{r }
# copy instance and replace raw counts with CLR-normalized counts
physeq.clr <- phyloseq_CLR(physeq.prev)
# otu_table(physeq.clr) <- otu_table(as(x, "matrix"), taxa_are_rows = FALSE)
physeq.clr
```
This one didn't work at first. It looks like one of the samples has no counts after prevalence filtering, so I'll remove that, and try again.

```{r }
physeq.prev <- prune_samples(sample_sums(physeq.prev)>0, physeq.prev)
#Redo above code as well
```


## CLR normalization, mixOmics

CLR from `mixOmics`.

```{r }
# get counts
tmp <- as(otu_table(physeq.prev),"matrix")

tmp <- tmp

# transpose if needed
if(!taxa_are_rows(physeq.prev)) { tmp <- t(tmp)}

x <- logratio.transfo(tmp, logratio = 'CLR', offset = 1)

# copy instance and replace raw counts with CLR-normalized counts
physeq.clr2 <- physeq.prev
otu_table(physeq.clr2) <- otu_table(as(x, "matrix"), taxa_are_rows = TRUE)
physeq.clr2
```
This one worked okay

## Set active instance

Set the active normalization type (Prop for now)

```{r}
physeq.active <- physeq.prop
#physeq.active <- physeq.clr
#physeq.active <- physeq.clr2
```


```{r }
finalPhyseq.ord <- ordinate(physeq.active, "NMDS", "bray")
p1 = plot_ordination(physeq.active,
                     finalPhyseq.ord,
                     type="samples",
                     color="Sample_Type",
                     label = "Horse",
                     title="Samples") + geom_point(size = 2.5)
p1 + ggtitle("NMDS plot of Bray Curtis distances") 

ggsave("NMDS_BrayCurtis_bySample_Type.pdf",path="./results/final-plots", device="pdf")
```

physeq.prop: RCr groups pretty well. Everything else groups somewhat. There tends to be an outlier in each grouping.
physeq.clr: Didn't work because of infinite or missing values.
physeq.clr2: This one has all the data points stacked on top of one another.


Does starting number of sequences affect groupings?
```{r }
p1 <- plot_ordination(physeq.active,
                     finalPhyseq.ord,
                     type="samples",
                     color="input",
                     label="SampleID",
                     title="Samples")
p1
```

Nothing odd here. Let's look at Weighted UniFrac

```{r}
finalPhyseq.ord <- ordinate(physeq.active, "PCoA", "wunifrac")
p1 = plot_ordination(physeq.active,
                     finalPhyseq.ord,
                     type="samples",
                     color="Location",
                   #  axes = c(1,2),
                     label = "Horse",
                     title="Samples") + geom_point(size=3)

p1 + ggtitle("PCoA plot of Weighted Unifrac distances") 

ggsave("PCoA_WeightedUnifrac_byLocation.pdf",path="./results/final-plots", device="pdf")
```

```{r}
p1 + facet_wrap(~Location)
```

physeq.prop: TTA, RD, and NPL group pretty decently
physeq.clr2: N/A

```{r}
p1 + facet_wrap(~Sample_Type)
```

physeq.prop: From this view, all of the groupings seem to be splitting at the y-axis around 0. None of the metadata fits this pattern, so I'm not sure what it could be.



## PERMANOVA

Let's try PERMANOVA on this using the implementation in `vegan` (`adonis2`). Let's start with the weighted unifrac
beta diversity metric.

```{r }
set.seed(12345)
finalPhyseq.meta <- as(sample_data(physeq.active), "data.frame")
finalPhyseq.prop.dist.bc <- phyloseq::distance(physeq.active, method = "wunifrac")
```


```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Location,
       data = finalPhyseq.meta)
```
physeq.prop: Location is not significant.
physeq.clr2: ""

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Sample_Type ,
       data = finalPhyseq.meta)
```

physeq.prop: Sample_Type is not significant.
physeq.clr2: ""

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Sex ,
       data = finalPhyseq.meta)
```
physeq.prop: Breed is not significant.
physeq.clr2: ""

More complex model:
```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Simple_Type*Breed,
       data = finalPhyseq.meta)
```
Still nothing significant in a more complex model.

Next we check for significance in differences between group dispersion. Ideally, these tests won't be significant.

```{r }
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Location)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Sample_Type)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Sex)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Breed)
permutest(beta)
```


physeq.prop: Good! This suggests that any issues with heteroscedasticity aren't likely to be significant.
physeq.clr2: ""


```{r }
plot(beta, main = "Weighted Unifrac Beta diversity PCoA by Location")
```

## Try Bray Curtis metric (non-phylogenetic)
```{r }
set.seed(12345)
finalPhyseq.meta <- as(sample_data(physeq.active), "data.frame")
finalPhyseq.prop.dist.bc <- phyloseq::distance(physeq.active, method = "bray")
```


```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Location,
       data = finalPhyseq.meta)
```
physeq.prop: Location is not significant.
physeq.clr2: ""

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Simple_Type ,
       data = finalPhyseq.meta)
```

physeq.prop: Sample_Type is better, but still not significant.
physeq.clr2: ""

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Breed ,
       data = finalPhyseq.meta)
```
physeq.prop: Breed is significant.
physeq.clr2: Breed is not significant.

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Horse ,
       data = finalPhyseq.meta)
```
physeq.prop: Horse is significant at 0.1
physeq.clr2: Horse is not significant.

More complex model:
```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Breed*Simple_Type,
       data = finalPhyseq.meta)
```
physeq.prop: In a more complex model, Breed is significant, but Sample_Type still is not.
physe.clr2: Not significant.

Next we check for significance in differences between group dispersion.

```{r }
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Sample_Type)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Location)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Sex)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Breed)
permutest(beta)
```
physeq.prop: Nothing is heteroscedastic.
physeq.clr2: Nothing is heterscedastic, but there was a warning earlier that PERMANOVA results may not be trustworthy since negative values were included. No surprise.

```{r }
plot(beta, main = "Bray Curtis Beta diversity PCoA by Location")
```
It seems clear that BAL differs from NPL and TTA in this PCoA plot. I'm going to try adding in another variable of BAL versus NPL+TTA and see if that is significant.

## Test significance for for BAL versus NPL+TTA

Add new variable to physeq.prop
```{r}
physeq.test <- physeq.prop
sample_data(physeq.test)$Simple_Type <- sample_data(physeq.test)$Sample_Type
levels(sample_data(physeq.test)$Simple_Type) <- c("NPL-TTA","NPL-TTA","BAL")
```

## Try Bray Curtis metric (non-phylogenetic)
```{r }
set.seed(12345)
finalPhyseq.meta <- as(sample_data(physeq.test), "data.frame")
finalPhyseq.prop.dist.bc <- phyloseq::distance(physeq.test, method = "bray")
```


```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Simple_Type,
       data = finalPhyseq.meta)
```
My new variable, Simple_Type, is highly significant. Let's test for heteroscedacity

```{r}
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Simple_Type)
permutest(beta)
```
It's not heteroscedastic, so that's great.

```{r }
plot(beta, main = "Bray Curtis Beta diversity PCoA by DFM presence/absence")
```
Let's try it for Weighted Unifrac as well.

```{r }
set.seed(12345)
finalPhyseq.meta <- as(sample_data(physeq.test), "data.frame")
finalPhyseq.prop.dist.bc <- phyloseq::distance(physeq.test, method = "wunifrac")
```

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Simple_Type,
       data = finalPhyseq.meta)
```
My new variable, Simple_Type, is not significant.

```{r}
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Simple_Type)
permutest(beta)
```
It's not heteroscedastic.

```{r }
plot(beta, main = "Bray Curtis Beta diversity PCoA by DFM presence/absence")
```

## ANOSIM

Let's run ANOSIM on the individual factors (using the Bray Curtis metric).  This test seems to have odd issues with stratification with some factors, but as stratifying based on tissue or subject ID seems to have very little effect on significance I will leave it out here.

```{r }
finalPhyseq.prop.ano <- anosim(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Location)
finalPhyseq.prop.ano
```
Not significant.


```{r }
plot(finalPhyseq.prop.ano, cex.axis = 0.6)
```

How about Sample_Type?

```{r }
finalPhyseq.prop.ano <- anosim(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Sample_Type)
finalPhyseq.prop.ano
```
This is significant at 0.1.

```{r }
plot(finalPhyseq.prop.ano)
```
How about Simple_Type?

```{r }
finalPhyseq.prop.ano <- anosim(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Simple_Type)
finalPhyseq.prop.ano
```
This is significant.

How about Breed?

```{r }
finalPhyseq.prop.ano <- anosim(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Breed)
finalPhyseq.prop.ano
```
This is significant.

```{r }
plot(finalPhyseq.prop.ano)
```


## Differential abundance analysis

Add Simple_Type to physeq.prev.

```{r}
sample_data(physeq.prev)$Simple_Type <- sample_data(physeq.prev)$Sample_Type
levels(sample_data(physeq.prev)$Simple_Type) <- c("NPL_TTA","NPL_TTA","BAL")
```


Run DESeq2.

```{r }
library(DESeq2)

targets <- sample_data(physeq.prev)

design <- model.matrix(~ Location, data = as(targets, "data.frame"))

finalPhyseq.adds = phyloseq_to_deseq2(physeq.prev, ~ Location)

finalPhyseq.adds = DESeq(finalPhyseq.adds, 
                         test="Wald", 
                         fitType="local",
                         sfType = "poscounts",
                         quiet = TRUE
                         )
```

What are the results names?

```{r}
resultsNames(finalPhyseq.adds)
```


Let's try pulling out contrasts. 
First lets create some functions to make this easier:
```{r }
generateContrastResults <- function(deseq, contrast, physeq, file = "results.txt") {
  res = results(deseq, 
              cooksCutoff = FALSE, 
              contrast = contrast,
              test = "Wald"
              )
  res = cbind(as(res, "data.frame"), as(tax_table(physeq)[rownames(res), ], "matrix"))
  
  write.table(res, file, row.names = TRUE, col.names = NA, sep = "\t")
  return(res)
}

plotDESeq2ResGenus <- function(res) {
  sigtab <- res[which(res$padj < 0.05), ]
  scale_fill_discrete <- function(palname = "Set1", ...) {
      scale_fill_brewer(palette = palname, ...)
  }
  
  x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
  
  # Genus order
  x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))
  p <- ggplot(sigtab, aes(x=Genus, y=log2FoldChange, color=Phylum)) + geom_point(size=6) +
    theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust=0.5, face = 'italic'),
          legend.text = element_text(face = 'italic'))
  return(p)
}

plotDESeq2ResFamily <- function(res) {
  sigtab <- res[which(res$padj < 0.05), ]
  scale_fill_discrete <- function(palname = "Set1", ...) {
      scale_fill_brewer(palette = palname, ...)
  }
  
  x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
  
  # Family order
  x = tapply(sigtab$log2FoldChange, sigtab$Family, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Family = factor(as.character(sigtab$Family), levels=names(x))
  p <- ggplot(sigtab, aes(x=Family, y=log2FoldChange, color=Phylum)) + geom_point(size=6) +
    theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust=0.5, face = 'italic'),
          legend.text = element_text(face = 'italic'))
  return(p)
}

plotDESeq2ResSpecies <- function(res) {
  sigtab <- res[which(res$padj < 0.05), ]
  scale_fill_discrete <- function(palname = "Set1", ...) {
      scale_fill_brewer(palette = palname, ...)
  }
  
  x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
  
  # Genus + Species order
  sigtab$GeneSpecies <- paste(sigtab$Genus,sigtab$Species)
  x = tapply(sigtab$log2FoldChange, sigtab$GeneSpecies, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$GeneSpecies = factor(as.character(sigtab$GeneSpecies), levels=names(x))
  p <- ggplot(sigtab, aes(x=GeneSpecies, y=log2FoldChange, color=Phylum)) + geom_point(size=6) +
    theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust=0.5, face = 'italic'),
          legend.text = element_text(face = 'italic'))
  return(p)
}
```


Try pulling out a specific contrast (TTA vs. NPL). The numbers in the contrast vector below correspond to the different test results we generated. 
[1] "Intercept"           "Location_TTA_vs_NPL" "Location_LD_vs_NPL"  "Location_LCd_vs_NPL" "Location_LCr_vs_NPL"
[6] "Location_RD_vs_NPL"  "Location_RCd_vs_NPL" "Location_RCr_vs_NPL"

```{r }
res.test = generateContrastResults(deseq = finalPhyseq.adds, 
                              contrast = c(0,1),
                           #   contrast = c(0,1,0,0,0,0,0,0),
                              physeq = physeq.prev,
                              file = "Diff-Abund-TTAandNPL_vs_BAL.txt"
)
dim(res.test[which(res.test$padj <= 0.05), ])
```
The first number above corresponds to the number of significant taxa (p <= 0.05) in this test result. 24 taxa are significantly different in abundance in this contrast.


Plot by Family rank. Taxa above 0 are more abundant in Salmonella, and taxa below 0 are more abundant in the control group.
```{r }
plotDESeq2ResFamily(res.test)
```

Now let's try the Genus rank
```{r }
plotDESeq2ResGenus(res.test)
```

Now let's try the Species rank
```{r }
plotDESeq2ResSpecies(res.test)
```


Run a loop that will save these tables and images for all the different pairwise contrasts.
```{r}
n.all <- sample_data(physeq.prev)$Location %>% levels()
for(x in 1:8){
  for(y in 1:8){
    if(x < y){  # Ignore useless and redundant files
      res.test <- generateContrastResults(deseq = finalPhyseq.adds, 
                                contrast = c("Location", 
                                             n.all[x],  # num
                                             n.all[y]), # denom
                                physeq = physeq.prev,
                                file = paste("results/diff-abund/location/tables/Diff-Abund_", n.all[x], "-vs-", n.all[y], ".txt", sep="")
      )
      plotDESeq2ResFamily(res.test)
      f <- paste("Diff-Abund_Family_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/location", device = "pdf")
      plotDESeq2ResGenus(res.test)
      f <- paste("Diff-Abund_Genus_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/location", device = "pdf")
      plotDESeq2ResSpecies(res.test)
      f <- paste("Diff-Abund_Species_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/location", device = "pdf")
    }
  }
}
```


What about differential abundance for Sample_Type?

```{r }
targets <- sample_data(physeq.prev)

design <- model.matrix(~ Sample_Type, data = as(targets, "data.frame"))

finalPhyseq.adds = phyloseq_to_deseq2(physeq.prev, ~ Sample_Type)

finalPhyseq.adds = DESeq(finalPhyseq.adds, 
                         test="Wald", 
                         fitType="local",
                         sfType = "poscounts",
                         quiet = TRUE
                         )
```

What are the results names?

```{r}
resultsNames(finalPhyseq.adds)
```

Run a loop that will save these tables and images for all the different pairwise contrasts.
```{r}
n.all <- sample_data(physeq.prev)$Sample_Type %>% levels()
for(x in 1:3){
  for(y in 1:3){
    if(x < y){  # Ignore useless and redundant files
      res.test <- generateContrastResults(deseq = finalPhyseq.adds, 
                                contrast = c("Sample_Type", 
                                             n.all[x],  # num
                                             n.all[y]), # denom
                                physeq = physeq.prev,
                                file = paste("results/diff-abund/sample_type/tables/Diff-Abund_", n.all[x], "-vs-", n.all[y], ".txt", sep="")
      )
      plotDESeq2ResFamily(res.test)
      f <- paste("Diff-Abund_Family_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/sample_type", device = "pdf")
      plotDESeq2ResGenus(res.test)
      f <- paste("Diff-Abund_Genus_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/sample_type", device = "pdf")
      plotDESeq2ResSpecies(res.test)
      f <- paste("Diff-Abund_Species_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/sample_type", device = "pdf")
    }
  }
}
```

What about differential abundance for Simple_Type (TTA+NPL vs BAL)?

```{r }
targets <- sample_data(physeq.prev)

design <- model.matrix(~ Simple_Type, data = as(targets, "data.frame"))

finalPhyseq.adds = phyloseq_to_deseq2(physeq.prev, ~ Simple_Type)

finalPhyseq.adds = DESeq(finalPhyseq.adds, 
                         test="Wald", 
                         fitType="local",
                         sfType = "poscounts",
                         quiet = TRUE
                         )
```

What are the results names?

```{r}
resultsNames(finalPhyseq.adds)
```

Run a loop that will save these tables and images for all the different pairwise contrasts.
```{r}
n.all <- sample_data(physeq.prev)$Simple_Type %>% levels()
for(x in 1:2){
  for(y in 1:2){
    if(x < y){  # Ignore useless and redundant files
      res.test <- generateContrastResults(deseq = finalPhyseq.adds, 
                                contrast = c("Simple_Type", 
                                             n.all[x],  # num
                                             n.all[y]), # denom
                                physeq = physeq.prev,
                                file = paste("results/diff-abund/simple_type/table/Diff-Abund_", n.all[x], "-vs-", n.all[y], ".txt", sep="")
      )
      plotDESeq2ResFamily(res.test)
      f <- paste("Diff-Abund_Family_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/simple_type", device = "pdf")
      plotDESeq2ResGenus(res.test)
      f <- paste("Diff-Abund_Genus_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/simple_type", device = "pdf")
      plotDESeq2ResSpecies(res.test)
      f <- paste("Diff-Abund_Species_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/simple_type", device = "pdf")
    }
  }
}
```
## Heatmaps

# Add extra label column
```{r}
sample_data(physeq.test)$label <- paste(sample_data(physeq.test)$Horse, sample_data(physeq.test)$Sex, sample_data(physeq.test)$Location, sep = ".")
physeq.active <- physeq.test

```

# Genus-level heatmaps
```{r}
#Agglomerate taxa and species level to remove redundancy
physeq.heat.glom <- tax_glom(physeq.active, taxrank = "Genus", NArm = FALSE)

# Genus is not NA
no.na <- !is.na(tax_table(physeq.heat.glom)[,"Genus"])
 # There are no NAs so skipping the next commands...

#Genus level in beneficial has a couple NAs that need to be renamed to Family
#tax_table(physeq.heat.glom)[!no.na][,"Genus"] = paste("[Family]", #tax_table(physeq.heat.glom)[!no.na][,"Family"])
```

Bray-Curtis heatmap
```{r}
p <- plot_heatmap(physeq.heat.glom,
                  method = "NMDS",
                  distance = "bray",
                  taxa.label = "Genus",
                  sample.label = "label",
                  sample.order = "Sex",
                  trans = log_trans(2),
                  title = "NMDS Bray-Curtis Heatmap")
p + theme(axis.text.y = element_text(face = 'italic', size = 8), axis.text.x = element_text(size = 8)) 

ggsave("bray-curtis-genus-level-heatmap-orderedBySexAndHorse.pdf", path = "~/Desktop/hpcbio-git/bishop-Shoreline-2021-Dec/TADA-Shoreline/results/heatmaps", device = "pdf")
```
Weighted Unifrac heatmap
```{r}
p <- plot_heatmap(physeq.heat.glom,
                  method = "NMDS",
                  distance = "wunifrac",
                  taxa.label = "Genus",
                  sample.label = "label",
                  sample.order = "Sample_Type",
                  trans = log_trans(2),
                  title = "NMDS Weighted Unifrac Heatmap")
p + theme(axis.text.y = element_text(face = 'italic', size = 8), axis.text.x = element_text(size = 8)) 

ggsave("weighted-unifrac-genus-level-heatmap-orderedBySampleType.pdf", path = "~/Desktop/hpcbio-git/bishop-Shoreline-2021-Dec/TADA-Shoreline/results/heatmaps", device = "pdf")
```



# Species-level heatmaps
```{r}
#Agglomerate taxa and species level to remove redundancy
physeq.heat.glom <- tax_glom(physeq.active, taxrank = "Species", NArm = FALSE)

#Genus level has some NAs that need to be renamed
 #tax_table(physeq.heat.glom)[!no.na][,"Genus"] = paste("[Family]",          v      tax_table(physeq.heat.glom)[!no.na][,"Family"])

#Replace "Unclassified" and NA species w/ "sp."
tax_table(physeq.heat.glom)[,"Species"][tax_table(physeq.heat.glom)[,"Species"] == "Unclassified"] <- "sp."
tax_table(physeq.heat.glom)[,"Species"][is.na(tax_table(physeq.heat.glom)[,"Species"])] <- "sp."

# Replace Species with full name
tax_table(physeq.heat.glom)[,"Species"] = paste(tax_table(physeq.heat.glom)[,"Genus"], tax_table(physeq.heat.glom)[,"Species"])
```

Bray-Curtis heatmap
```{r}
p <- plot_heatmap(physeq.heat.glom,
                  method = "NMDS",
                  distance = "bray",
                  taxa.label = "Species",
                  sample.label = "label",
                  sample.order = "Location",
                  trans = log_trans(2),
                  title = "NMDS Bray-Curtis Heatmap")
p + theme(axis.text.y = element_text(face = 'italic', size = 8), axis.text.x = element_text(size = 8)) 

ggsave("bray-curtis-species-level-heatmap-orderedByLocation.pdf", path = "~/Desktop/hpcbio-git/bishop-Shoreline-2021-Dec/TADA-Shoreline/results/heatmaps", device = "pdf")
```

Weighted Unifrac heatmap
  # Note to self: make loop for different variables to order by
```{r}
p <- plot_heatmap(physeq.heat.glom,
                  method = "NMDS",
                  distance = "wunifrac",
                  taxa.label = "Species",
                  sample.label = "label",
                  sample.order = "Sex",
                  trans = log_trans(2),
                  title = "NMDS Weighted Unifrac Heatmap")
p + theme(axis.text.y = element_text(face = 'italic', size = 8), axis.text.x = element_text(size = 8)) 

ggsave("weighted-unifrac-species-level-heatmap-orderedBySexAndHorse.pdf", path = "~/Desktop/hpcbio-git/bishop-Shoreline-2021-Dec/TADA-Shoreline/results/heatmaps", device = "pdf")
```




# Save

```{r }
saveRDS(physeq.prop, file = "~/Desktop/hpcbio-git/bishop-Shoreline-2021-Dec/TADA-Shoreline/results/phyloseq-prev-prop.RDS")
```

# Session

```{r }
sessionInfo()
```

