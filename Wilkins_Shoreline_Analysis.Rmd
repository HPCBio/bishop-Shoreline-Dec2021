---
title: "Wilkens-Bishop Shoreline Dec 2021 - Data analysis"
author: "Jessica Holmes, Chris Fields"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    pdf_print: paged
    fig_height: 4
    fig_width: 6
    toc: yes
  word_document:
    toc: yes
    fig_height: 4
    fig_width: 6
  pdf_document:
    toc: yes
  powerpoint_presentation:
    toc: no
    fig_height: 4
    fig_width: 6
---

# Intro

This is the primary analysis file (including code) for a horse lung project using Shoreline's StrainID kit. The input data was processed using the [TADA pipeline](https://github.com/h3abionet/TADA) and the pacbio.nf script. While these were Shoreline sequences, only the 16S sequence was used, as the results with the full Shoreline sequences were not as accurate. 

# Set up

Code (not shown in the report) is initialized and loaded here.  We don't include the code in the report but make this available as needed; please see the [Github repository](https://github.com/HPCBio/bishop-Shoreline-2021-Dec) for this project for the final version.

Data from the primary project folder should be downloaded from [here](https://uofi.box.com/s/icv26axm4j1j4f51geegrvh2zli2vqmz) (requires permissions). Note the following assumes all data are in `2021-Dec-Shoreline`.

```{r, echo=TRUE, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r, include=FALSE}
# Note that not all libraries will be needed.  Most phyloseq code uses ggplot and tidyverse internally, therefore we explicitly load here
library(knitr)
library(tidyverse)
library(phyloseq)

# For normalization
library(metagenomeSeq)

# phylogenetic tree input
library(ape)

# read/modify BIOM 
library(biomformat)

# ggplot functions for trees and dendrograms
library(ggdendro)

# distance measures, PERMANOVA, ANOSIM
library(vegan)

# generation of stats values for graphs
library(ggpubr)

# normalization (CLR)
library(mixOmics)

# to get labels2color
library(WGCNA)

# mixed models (needs to be updated)
library(lme4)
library(lmerTest)
library(nlme)

# to get post-hoc tests for mixed-model tests 
library(lsmeans)
library(devtools)

#Other libraries 
library(plotly.microbiome)
library(microbiome)
library(ranacapa)
library(Biostrings)
library(readxl)
library(scales)
library(microViz)

# this is to load some extension helper code, see: https://github.com/HPCBio/phyloseq-extended
devtools::load_all('./phyloseq-extended/')
```

```{r, include=FALSE}
# Setting up the analysis, including adding helper functions.  The document won't include the actual code, but the functions are present in the Rmd document.  The functions here include ones to:
options(stringsAsFactors = FALSE)
theme_set(theme_bw())
```


## Functions

```{r, include=FALSE}
# Remove the tags on the taxonomic ranks, which are redundant with the column headers.
stripTaxaTags <- function(physeq) {
  oldMA <- as(tax_table(physeq), "matrix")
  newMA <- apply(oldMA, 2, function(x) {sub('\\w__','', x)})
  if (inherits(physeq, "taxonomyTable")) {
      return(tax_table(newMA))
  }
  else {
      tax_table(physeq) <- tax_table(newMA)
      return(physeq)
  }
}
```

```{r }
# Convert sequences to names (culled from https://github.com/LangilleLab/microbiome_helper/blob/master/convert_dada2_out.R) 

renameTaxIds <- function(physeq, file.name="seqs.fasta") {
  suppressMessages(require("ShortRead"))
  seqtab.physeq <- otu_table(physeq)
  seqs <- colnames(seqtab.physeq)
  ids_study <- paste("seq", 1:ncol(seqtab.physeq), sep = "_")
  seqs.dna <- ShortRead(sread = DNAStringSet(seqs), id = BStringSet(ids_study))
  # Write out fasta file.
  writeFasta(seqs.dna, file = file.name)
  taxa_names(physeq) <- ids_study
  # TODO: add the sequences back to the phyloseq instance
  # physeq <- merge_phyloseq(physeq)
  return(physeq)
}
```

```{r}
# original code: https://github.com/twbattaglia/btools/blob/master/R/estimate_pd.R
estimate_pd <- function(phylo) {
  # Error if input is not of class phylo
  if(class(phylo) != "phyloseq"){
    stop("Input file is not of class 'phyloseq'.")
  }

  # Error if no class phy_tree
  if(!(.hasSlot(phylo, "phy_tree"))){
    stop("Could not find tree slot in phylo object.")
  }
  
  if (!require('picante')) stop("Function requires the picante library.")

  # Transpose if needed
  # Adapted from phyloseq/vegan import
  OTU <- phyloseq::otu_table(phylo)
  if (taxa_are_rows(OTU)) {
    OTU <- t(OTU)
  }

  # Get matrix version of OTU table
  otutable <- as(OTU, "matrix")

  # Get phylogenetic tree from phyloseq object
  tree <- phyloseq::phy_tree(phylo)

  # Print status message
  message("Calculating Faiths PD-index...")

  # If object is greater than 10mb, then print status message
  if(object.size(otutable) > 10000000){
    message("This is a large object, it may take awhile...")
  }

  # Calculate Faith's PD-index
  #
  pdtable <- picante::pd(otutable, tree, include.root = F)

  # Return data frame of results
  return(pdtable)
}
```

```{r}
# CLR normalization 
# (from McMurdie (Meth Mol Bio 2018) supplemental package)
zero_comp = function(x){
  if(taxa_are_rows(x)){x <- t(x)}
  matx = otu_table(x)
  # `zCompositions::cmultRepl` expects the samples to be in rows and OTUs to be in columns
  matxzc = zCompositions::cmultRepl(matx, method="CZM", output="p-counts")
  otu_table(x) <- otu_table(matxzc, taxa_are_rows = FALSE)
  return(x)
}
# CLR definition
geometric_mean = function(x){
  exp(mean(log(x)))
}
clr = function(x, base=2){
  x <- log((x / geometric_mean(x)), base)
}
phyloseq_CLR = function(physeq){
  suppressMessages({physeq <- zero_comp(physeq)})
  return(transform_sample_counts(physeq, fun = clr))
}
```

```{r}
# this is a modification of the plot_richness function from phyloseq, but takes as input a pre-generated matrix of estimates from `estimate_richness` or any other function, plus the phyloseq instance.  
plot_richness_estimates = function(physeq, 
                                   erDF, 
                                   x="samples", 
                                   color=NULL, 
                                   shape=NULL, 
                                   title=NULL,
                                   scales="free_y", 
                                   nrow=1, 
                                   sortby=NULL) {
  # TODO: add sanity check on matrix (e.g. rows == sample IDs, sample names, and column names)
  
  # Measures may have been renamed in `erDF`. Replace it with the name from erDF
  measures = colnames(erDF)
  # Define "measure" variables and s.e. labels, for melting.
  ses = colnames(erDF)[grep("^se\\.", colnames(erDF))]
  # Remove any S.E. from `measures`
  measures = measures[!measures %in% ses]
	# Make the plotting data.frame.
  # This coerces to data.frame, required for reliable output from reshape2::melt()
  if( !is.null(sample_data(physeq, errorIfNULL=FALSE)) ){
    # Include the sample data, if it is there.
	  DF <- data.frame(erDF, sample_data(physeq))
  } else {
    # If no sample data, leave it out.
    DF <- data.frame(erDF)
  }
	if( !"samples" %in% colnames(DF) ){
	  # If there is no "samples" variable in DF, add it
		DF$samples <- sample_names(physeq)
	}
	# sample_names used to be default, and should also work.
	# #backwardcompatibility
	if( !is.null(x) ){
		if( x %in% c("sample", "samples", "sample_names", "sample.names") ){
			x <- "samples"
		}
	} else {
    # If x was NULL for some reason, set it to "samples"
	  x <- "samples"
	}
	# melt to display different alpha-measures separately
	mdf = reshape2::melt(DF, measure.vars=measures)
  # Initialize the se column. Helpful even if not used.
  mdf$se <- NA_integer_
  if( length(ses) > 0 ){
    ## Merge s.e. into one "se" column
    # Define conversion vector, `selabs`
    selabs = ses
    # Trim the "se." from the names
    names(selabs) <- substr(selabs, 4, 100)
    # Make first letter of selabs' names uppercase
    substr(names(selabs), 1, 1) <- toupper(substr(names(selabs), 1, 1))
    # use selabs conversion vector to process `mdf`
    mdf$wse <- sapply(as.character(mdf$variable), function(i, selabs){selabs[i]}, selabs)
    for( i in 1:nrow(mdf) ){
      if( !is.na(mdf[i, "wse"]) ){
        mdf[i, "se"] <- mdf[i, (mdf[i, "wse"])]
      }
    }
    # prune the redundant columns
    mdf <- mdf[, -which(colnames(mdf) %in% c(selabs, "wse"))]
  }
  ## Interpret measures
  # If not provided (default), keep all 
  if( !is.null(measures) ){
    if( any(measures %in% as.character(mdf$variable)) ){
      # If any measures were in mdf, then subset to just those.
      mdf <- mdf[as.character(mdf$variable) %in% measures, ]
    } else {
      # Else, print warning about bad option choice for measures, keeping all.
      warning("Argument to `measures` not supported. All alpha-diversity measures (should be) included in plot.")
    }
  }
  # Address `sortby` argument
  if(!is.null(sortby)){
    if(!all(sortby %in% levels(mdf$variable))){
      warning("`sortby` argument not among `measures`. Ignored.")
    }
    if(!is.discrete(mdf[, x])){
      warning("`sortby` argument provided, but `x` not a discrete variable. `sortby` is ignored.")
    }
    if(all(sortby %in% levels(mdf$variable)) & is.discrete(mdf[, x])){
      # Replace x-factor with same factor that has levels re-ordered according to `sortby`
      wh.sortby = which(mdf$variable %in% sortby)
      mdf[, x] <- factor(mdf[, x],
                         levels = names(sort(tapply(X = mdf[wh.sortby, "value"],
                                                    INDEX = mdf[wh.sortby, x],
                                                    mean,
                                                    na.rm=TRUE, simplify = TRUE))))
    }
  }
  # Define variable mapping
  richness_map = aes_string(x=x, y="value", colour=color, shape=shape)
  # Make the ggplot.
  p = ggplot(mdf, richness_map) + geom_point(na.rm=TRUE)  
  # Add error bars if mdf$se is not all NA
  if( any(!is.na(mdf[, "se"])) ){
    p = p + geom_errorbar(aes(ymax=value + se, ymin=value - se), width=0.1) 
  }
  # Rotate horizontal axis labels, and adjust
	p = p + theme(axis.text.x=element_text(angle=-90, vjust=0.5, hjust=0))
	# Add y-label 
	p = p + ylab('Alpha Diversity Measure') 
  # Facet wrap using user-options
	p = p + facet_wrap(~variable, nrow=nrow, scales=scales)
	# Optionally add a title to the plot
	if( !is.null(title) ){
		p <- p + ggtitle(title)
	}
	return(p)
}

```


# Import and preprocessing

## Initial file input - PacBio

Load in taxonomy, sequences, tree, and ASVs (metadata to be added later).

```{r}
q2 <- readRDS('2021-Dec-PacBio/Phyloseq/tax_final.simple.RDS')
knitr::kable(head(q2))
```

```{r}
colnames(q2) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")
knitr::kable(head(q2))
```

```{r}
seqtab.tmp <- readRDS('2021-Dec-PacBio/Phyloseq/seqtab_final.simple.RDS')
tree.tmp <- read_tree('2021-Dec-PacBio/Plain/Trees/rooted.newick')
asvs.tmp <- Biostrings::readDNAStringSet('2021-Dec-PacBio/Plain/Sequences/asvs.md5.nochim.fna', format = 'fasta')
physeq.pacbio <- phyloseq(
  otu_table(seqtab.tmp, taxa_are_rows = F),
  tax_table(q2),
  asvs.tmp,
  tree.tmp)
```


The sample names need to be cleaned up
```{r}
tmp <- sample_names(physeq.pacbio)
tmp <- gsub('.filtered.*', '', tmp)
sample_names(physeq.pacbio) <- tmp
```


## Load metadata

Load in experimental data on samples (metadata).

```{r}
tmp <- read_tsv('reference/Bishop_sample_metadata.txt', comment = '#q2')
tmp$Well <- factor(tmp$Well)
tmp$Horse <- factor(tmp$Horse)
tmp$Sample_Type <- factor(tmp$Sample_Type)
tmp$Location <- factor(tmp$Location)
tmp$Sex<- factor(tmp$Sex)
tmp$Breed <- factor(tmp$Breed)
tmp$Simple_Type <- tmp$Sample_Type
levels(tmp$Simple_Type) <- c("BAL","NPL-TTA","NPL-TTA")
colnames(tmp)[1] <- "SampleID"
tmp
```

We also read in read QC.

```{r results="asis"}
library(dada2)
getN <- function(x) sum(getUniques(x))

# the gsub here might be a bit brittle...
dadas <- as.data.frame(
    sapply(readRDS("2021-Dec-PacBio/dada2/dada2-Derep-Pooled/all.dds.RDS"), getN)
    )
rownames(dadas) <- gsub('.filtered.*','',rownames(dadas))
dadas$SampleID <- rownames(dadas)

seqtab.nochim <- as.data.frame(rowSums(readRDS("2021-Dec-PacBio/Phyloseq/seqtab_final.simple.RDS")))
rownames(seqtab.nochim) <- gsub('.filtered.fastq.*', '',rownames(seqtab.nochim))
seqtab.nochim$SampleID <- rownames(seqtab.nochim)

trimmed <- read.csv("2021-Dec-PacBio/dada2/dada2-FilterAndTrim/all.trimmed.csv")
rownames(trimmed) <- gsub('.noprimer.fastq.*', '',trimmed$Sequence)
trimmed$SampleID <- rownames(trimmed)

track <- Reduce(function(...) merge(..., by = "SampleID",  all.x=TRUE),  list(trimmed, dadas, seqtab.nochim))
# dropped data in later steps gets converted to NA on the join
# these are effectively 0
track[is.na(track)] <- 0

colnames(track) <- c("SampleID", "Sequence", "input", "filtered", "denoised", "nonchim")
write.table(track, "all.readtracking.txt", sep = "\t", row.names = FALSE)

```


Now combine all metadata together for analysis and add back to the class.

```{r}
#Combine metadata
tmp2 <- sample_data(right_join(tmp, track, by="SampleID"))
sample_names(tmp2) <- tmp2$SampleID
sample_data(physeq.pacbio) <- tmp2
```


# Raw composition plots

Overall compositional summary (stacked bar plots) for samples.

```{r }
#Phyloseq bar plot
p <- plot_bar(physeq.pacbio, x="SampleID", fill="Class")
p
```


Check Domain breakdown.
```{r}
table(tax_table(physeq.pacbio)[,'Domain'])
```



# Sample and Taxa Filtering

The steps below are standard filtering steps that will differ per analysis. 

## Focus on only experimental samples 

In this analysis we are considering all of the data and don't subset anything.  Any sample-specific quality issues that need filtering are addressed as outliers below.

## Removing artifacts

We do need to remove ASVs that are likely artifactual, for example from host, and that we want to remove.  We should get rid of:

* Unranked/unassigned
* Eukarya (kingdom)
* Mitochondria
* Chloroplast

The RDP classifier will misclassify sequences that have very little sequence similarity to 16S based on the way it works; these tend to classify poorly by rank (NA or 'Unclassified' up to and sometimes including Domain/Kingdom).  

How many are unclassified at Domain level?

```{r }
table(tax_table(physeq.pacbio)[,'Domain']) %>% kable
```

None to remove.


### Organelle 16S (mitochondria, chloroplast)

Next we check for organelle 16S.  These could arise in chloroplast or mitochondria.  They are classified under different rank criteria in Silva, so we need to check for them separately. 

Any hits for chloroplast? These are found under the `Order` rank.

```{r }
table(tax_table(physeq.pacbio)[,'Order'])['Chloroplast']
```

2 chloroplast sequences.


Any mitochondrial sequences?  

```{r }
table(tax_table(physeq.pacbio)[,'Family'])['Mitochondria']
```

No mitochondrial sequences


Remove cholorplasts

```{r }
# remove chloroplasts
physeq.filtered <- subset_taxa(physeq.pacbio, Order != 'Chloroplast')
```


## Prune low count samples

Remove samples with less than 1500 sequences.

```{r}
physeq.filtered <- prune_samples(sample_sums(physeq.filtered) > 1500, physeq.filtered)
```


## Remove taxa with 0 counts

Filter out any taxa with 0 counts.

```{r }
physeq.filtered <- prune_taxa(taxa_sums(physeq.filtered) > 0, physeq.filtered)
physeq.filtered
```



# Basic overview

Let's look at the data.  We have `r ntaxa(physeq.filtered)` taxa and `r nsamples(physeq.filtered)` samples.

Before plotting, let's change the order of metadata.

```{r}
#Rearrange location order
sample_data(physeq.filtered)$Location <- factor(sample_data(physeq.filtered)$Location,levels = c("NPL","TTA","LD","LCd","LCr","RD","RCd","RCr"))
sample_data(physeq.filtered)$Sample_Type <- factor(sample_data(physeq.filtered)$Sample_Type,levels = c("NPL","TTA","BAL"))
```


# Alpha rarefaction

This is a simple alpha rarefaction curve.

```{r, include=FALSE}
p <- suppressMessages(ranacapa::ggrare(physeq.filtered, step = 50,
            color = "Location",
         #   label = "SampleID",
            se = FALSE,
            plot = FALSE,
            ))
```

```{r}
p + ggtitle("Alpha Rarefaction") + coord_cartesian(xlim=c(0,125000), ylim=c(0,500))
```


# Composition plot (before prevalance filtering)

Overall compositional summary before prevalance filtering.

```{r }
#Phyloseq bar plot
p <- plot_bar(physeq.filtered, x="SampleID", fill="Class")
p + theme(legend.key.size = unit(0.25, 'cm'), #change legend key size
        legend.title = element_text(size=8), #change legend title font size
        legend.text = element_text(size=8),
        axis.text.x = element_blank()) +
        facet_wrap(~Location, scales = "free_x")
```


# Alpha diversity

Check alpha diversity stats.  Note we haven't performed any additional filtering or agglomeration at this stage; this is largely due to recommendations to prevent loss of rare ASVs or singletons in the data, which can dramatically affect alpha diversity measures.  Specifically (from the `plot_richness` function used here):

> You must use untrimmed, non-normalized count data for meaningful results, as many of these estimates are highly dependent on the number of singletons. You can always trim the data later on if needed, just not before using this function.

## Calculate alpha diversity measures

```{r}
# Chao1 & Simpson
erDF <- estimate_richness(physeq.filtered, measures = c("Chao1","Simpson"))

# add Faith's PD
pd <- estimate_pd(physeq.filtered)
erDF$PD <- pd$PD

measures <- colnames(erDF)
```


### Plot to check normality

```{r }
par(mfrow = c(2, 3))

plots <- lapply(c('Chao1','Simpson', 'PD'), 
       function(x) {
         shap <- shapiro.test(erDF[,x])
         hist(erDF[,x], xlab = "Measure", main=paste0(x, "\nShapiro pvalue=", label_number(accuracy = 0.0001)(shap$p.value)), breaks=15)
         })
```

Non-parametric tests will be needed.


### Alpha diversity plots

```{r}
p <- plot_richness_estimates(physeq = physeq.filtered, 
                             erDF = erDF, 
                             "Simple_Type", 
                             color = "Simple_Type", 
                             title="Alpha diversity for BAL vs (NPL+TTA)")

p + geom_boxplot(aes(x=Simple_Type, 
                     y=value,
                     color=NULL), alpha=0.1) +
  stat_compare_means(label = "p.signif",
                     hide.ns = TRUE,
                     method = "wilcox.test") +
  ylab("Faith PD") + 
  theme(legend.position = "none")
```


Write out p-values and index values for Simple_Type groupings

```{r}
# Convert plotting data
data <- ggplot_build(p)

# run separate test to get p values
chao1.vals <- compare_means(value ~ Simple_Type, data = data$plot$data[c(1:28),], method = "wilcox.test")
simpson.vals <- compare_means(value ~ Simple_Type, data = data$plot$data[c(29:56),], method = "wilcox.test")
pd.vals <- compare_means(value ~ Simple_Type, data = data$plot$data[c(57:84),], method = "wilcox.test")

# merge tables
chao1.vals$metric <- "Chao1"
simpson.vals$metric <- "Simpson"
pd.vals$metric <- "Faith PD"
pre.final <- merge(chao1.vals, simpson.vals, all = TRUE)
final.vals <- merge(pre.final, pd.vals, all = TRUE)

#write out the tables
write.table(data$plot$data, file = "results/alpha-and-taxa-plots/bal_vs_npl-tta_raw_alpha_values.csv", sep =",", row.names = FALSE)
write.table(final.vals, file = "results/alpha-and-taxa-plots/bal_vs_npl-tta_Wilcoxon_p-values.csv", sep =",", row.names = FALSE)
```


All alpha diversity metrics by Sample_Type:
```{r}
p <- plot_richness_estimates(physeq = physeq.filtered, 
                             erDF = erDF,
                             "Sample_Type", 
                             color = "Sample_Type", 
                             title="Alpha diversity by Sample Type")

p + geom_boxplot(aes(x=Sample_Type, 
                     y=value, 
                     color=NULL), alpha=0.1) +
  stat_compare_means(label = "p.signif",
                     method = "wilcox.test",
                     hide.ns = TRUE) +
  ylab("Alpha diversity score") + 
  theme(legend.position = "none")
```


Write out p-values and index values for Sample_Type groupings

```{r}
# Convert plotting data to be used for other things
data <- ggplot_build(p)

# run separate test to get p values
chao1.vals <- compare_means(value ~ Sample_Type, data = data$plot$data[c(1:28),], method = "wilcox.test")
simpson.vals <- compare_means(value ~ Sample_Type, data = data$plot$data[c(29:56),], method = "wilcox.test")
pd.vals <- compare_means(value ~ Sample_Type, data = data$plot$data[c(57:84),], method = "wilcox.test")

# merge tables
chao1.vals$metric <- "Chao1"
simpson.vals$metric <- "Simpson"
pd.vals$metric <- "Faith PD"
pre.final <- merge(chao1.vals, simpson.vals, all = TRUE)
final.vals <- merge(pre.final, pd.vals, all = TRUE)

#write out the tables
write.table(data$plot$data, file = "results/alpha-and-taxa-plots/bal_vs_npl_vs_tta_raw_alpha_values.csv", sep =",", row.names = FALSE)
write.table(final.vals, file = "results/alpha-and-taxa-plots/bal_vs_npl_vs_tta_Wilcoxon_p-values.csv", sep =",", row.names = FALSE)
```



For Location grouping, will first remove TTA & NPL samples
```{r}
physeq.bal <- prune_samples(sample_data(physeq.filtered)$Simple_Type == "BAL", physeq.filtered)
```

Re-calculate indices
```{r}
erDF <- estimate_richness(physeq.bal, measures = c("Chao1","Shannon"))
pd <- estimate_pd(physeq.bal)
erDF$PD <- pd$PD
measures <- colnames(erDF)
```

Plot alpha diversity for Location
```{r}
p <- plot_richness_estimates(physeq = physeq.bal, 
                             erDF = erDF, # all metrics
                             "Location", 
                             color = "Location", 
                             title="Alpha diversity in different BAL locations")

p + geom_boxplot(aes(x=Location, 
                     y=value, 
                     color=NULL), alpha=0.1) +
  stat_compare_means(label = "p.signif",
                     method = "wilcox.test",
                     hide.ns = TRUE) +
  ylab("Alpha diversity score") + 
  theme(legend.position = "none")
```


Write out p-values and index values for Location groupings

```{r}
# Convert plotting data to be used for other things
data.bal <- ggplot_build(p)

# run separate test to get p values
chao1.vals <- compare_means(value ~ Location, data = data.bal$plot$data[c(1:28),], method = "wilcox.test")
simpson.vals <- compare_means(value ~ Location, data = data.bal$plot$data[c(29:56),], method = "wilcox.test")
pd.vals <- compare_means(value ~ Location, data = data.bal$plot$data[c(57:84),], method = "wilcox.test")

# merge tables
chao1.vals$metric <- "Chao1"
simpson.vals$metric <- "Simpson"
pd.vals$metric <- "Faith PD"
pre.final <- merge(chao1.vals, simpson.vals, all = TRUE)
final.vals <- merge(pre.final, pd.vals, all = TRUE)

#write out the tables
write.table(data.bal$plot$data, file = "results/alpha-and-taxa-plots/bal-locations_raw_alpha_values.csv",sep = ",", row.names = FALSE)
write.table(final.vals, file = "results/alpha-and-taxa-plots/bal-locations_Wilcoxon_p-values.csv",sep = ",", row.names = FALSE)
```



# Tip agglomeration

Tip agglomeration is recommended for PacBio sequenced data to remove short branch tips, which appear to be an artifact of sequencing. Agglomeration is based on the cophenetic distance, the pairwise distances between tips on the tree.

## Data exploration

Plot distribution of tip distances.

```{r PrevalenceFiltering-15}
cp_phylo <- cophenetic.phylo(phy_tree(physeq.filtered))

hist(cp_phylo, 
     breaks = 100, 
     main = "Pairwise distance between tips", 
     xlab = "Distance between tips")
    # xlim = c(-0.5, 3))

cutoff <- c(seq(0.025, 0.175, 0.025), 0.2, 0.3, 0.5, 0.75, 1, 2)
abline(v=cutoff, col = "red")
text(cutoff, max(hist(cp_phylo, 100, plot=FALSE)$counts), labels = cutoff, pos = 2, srt = 90, cex = .5 )
```


Re-plot in log scale.  

```{r PrevalenceFiltering-16}
hist(log(cp_phylo), 
     breaks = 200, 
     main = "Pairwise distance between tips", 
     xlab = "Distance between tips (log)",
     xlim = c(-5, 2))

abline(v=log(cutoff), col = "red")
text(log(cutoff), max(hist(log(cp_phylo), 100, plot=FALSE)$counts), labels = cutoff, pos = 2, srt = 90, cex = .5 )
```

Apply tip_glom at viable cutoffs

```{r PrevalenceFiltering-17}
pseqs <- lapply(cutoff[1:10], function(x) {tip_glom(physeq.filtered, h = x)})
names(pseqs) <- cutoff[1:10]
```

Display trees at each cutoff

```{r PrevalenceFiltering-18}
pseqs.final <- pseqs[sapply(pseqs, function(x) {
  !is.null( tryCatch({phy_tree(x)}, error = function(cond) { return(NULL) }) )
  }, simplify = TRUE)]

plots <- sapply(names(pseqs.final), function(x) {
  plot_tree(pseqs.final[[x]], 
          nodelabf = nodeplotblank,
          ladderize = "left", 
          method = "treeonly") + 
  ggtitle(paste0("Height:",x, ", ", ntaxa(pseqs.final[[x]]), " taxa")) + 
    theme(plot.title = element_text(size = 10))
  }, simplify = FALSE
  )

grid.arrange(grobs = prepend(plots, list(Original = p)),
             nrow = 3)

```

## Final tip agglomeration cutoff
To balance taxonomic specificity with sequences retained after prevalence filtering (next section), a cutoff of 0.1 was chosen for the final tip agglommeration. 

```{r PrevalenceFiltering-22}
physeq.glom <- pseqs.final[['0.1']]
```

# Prevalence filtering

Create prevalence table

```{r PrevalenceFiltering-26 }
#Calculate a vector with the count being the # samples with a count > 0.
prevdf <- apply(otu_table(physeq.glom),  # counts
               MARGIN = ifelse(taxa_are_rows(physeq.glom), yes = 1, no = 2), 
               # how many times the counts in the samples are greater than 0
               FUN = function(x){sum(x > 0)}  
               )
prevdf <- data.frame(Prevalence =  prevdf, # num samples counts are > 0
                     TotalAbundance = taxa_sums(physeq.glom), # total abundance
                     tax_table(physeq.glom)) # tax ID and ranks
```


Set prevalence threshold to 7.5% (ASV must be observed in 2 samples), then perform filtering.

```{r PrevalenceFiltering-31}
pthresh <- 0.075

prevThreshold <- pthresh * nsamples(physeq.glom)

keepTaxa <- rownames(prevdf)[(prevdf$Prevalence >= prevThreshold)]
physeq.prev <- prune_taxa(keepTaxa, physeq.glom)
physeq.prev
```

Save data

```{r PrevalenceFiltering-35 }
# Save
if (!file.exists('./results/PrevalenceFiltering/')){
    dir.create(file.path('./results/PrevalenceFiltering/'), recursive = TRUE)
}
saveRDS(physeq.prev, file = "results/PrevalenceFiltering/phyloseq.prevfiltered.RDS")
```




# Basic composition plots on prevalence filtered & agglomerated data

Order faceted wrapped by Location
```{r }
p <- plot_bar(physeq.prev, x="Horse", fill="Order")
p + theme(legend.key.size = unit(0.2, 'cm'), #change legend key size
        legend.title = element_text(size=8), #change legend title font size
        legend.text = element_text(size=8, face="italic")) +
  guides(fill = guide_legend(nrow = 30)) +
  facet_wrap(~Location, scales = "free_x")

ggsave("filtered-taxonomy-bar-plot_Order-level_byLocation.pdf",path="results/alpha-and-taxa-plots//", height = 8, width = 9, device="pdf")
```


Family faceted by Simple Type
```{r }
p <- plot_bar(physeq.prev, x="SampleID", fill="Family")
p + theme(legend.key.size = unit(0.2, 'cm'), #change legend key size
        legend.title = element_text(size=8), #change legend title font size
        legend.text = element_text(size=8, face="italic")) +
  guides(fill = guide_legend(nrow = 30)) +
  facet_wrap(~Simple_Type, scales = "free_x")

ggsave("filtered-taxonomy-bar-plot_Family-level_bySimpleType.pdf",path="results/alpha-and-taxa-plots/", height = 8, width = 10, device="pdf")
```


# Relative abundance tables (overall)

```{r}
#Get relative abundance
physeq.prev.prop <- transform_sample_counts(physeq.prev, function(x) x/sum(x) )
sample_data(physeq.prev.prop)$SampleSums <- sample_sums(physeq.prev)

physeq.prev.prop <- physeq.prev.prop %>% tax_fix(unknowns = c("Unclassified"," unidentified"," uncultured", " uncultured_bacterium", " uncultured_prokaryote", " unidentified_eubacterium"))

physeq.plot <- physeq.prev.prop
```

Overall compositional summary (stacked bar plots) for all prevalence filtered and tip agglomerated samples.  In this example, just the top 20 taxa are included for each taxonomical ranking.

```{r, results='asis', fig.keep='all', message = FALSE, warning = FALSE, echo = FALSE}
ranks <- c("Phylum", "Class", "Order", "Family", "Genus", "Species")
plots <- lapply(ranks, function (x) { 


  #Plot relative abundance
  p <- comp_barplot(physeq.plot, x, n_taxa = 20, facet_by = "Location",  label = "Horse", palette = dittoSeq::dittoColors())
  p1 <- p + theme(legend.key.size = unit(0.25, 'cm'),
        legend.title = element_text(size=6),
        legend.text = element_text(size=6),
        axis.title.x=element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x = element_text(size = 6, angle = 90, #Needed for labels
                                  hjust = 1, vjust = 1,
                                   face = "bold")) +
        ylab("Relative Abundance") +
        guides(fill = guide_legend(nrow = 30))

 p1
 f1 <- paste("results/final-plots/taxa-bar-plots/taxa-rank-" , x , "_barplot_top20_splitby_Location.pdf", sep = "")
 ggsave(f1, device = "pdf")
})
```



# Relative abundance tables (grouped by Sample_Type)

Group data by Sample_Type (averaging the ASV counts per Sample_Type group) and then re-plot the composition bar plots. Here, the first 20 taxa are shown in each plot and the rest are categorized into the "Other" category.

```{r, warning=FALSE}
#Get relative abundance
physeq.prev1 <- merge_samples(physeq.prev, "Sample_Type")
physeq.prev.prop <- transform_sample_counts(physeq.prev1, function(x) x/sum(x) )
sample_data(physeq.prev.prop)$SampleSums <- sample_sums(physeq.prev1)
physeq.plot <- physeq.prev.prop
physeq.plot <- physeq.plot %>% tax_fix(unknowns = c("Unclassified"," unidentified"," uncultured", " uncultured_bacterium", " uncultured_prokaryote", " unidentified_eubacterium"))
```



```{r, results='asis', fig.keep='all', message = FALSE, warning = FALSE, echo = FALSE}
ranks <- c("Phylum","Class", "Order", "Family", "Genus", "Species")

s.order <- c("NPL","TTA","BAL")

plots <- lapply(ranks, function (x) { 
  
#Plot relative abundance
  p <- comp_barplot(physeq.plot, x, n_taxa = 20, palette = dittoSeq::dittoColors(), sample_order = s.order)
  p1 <- p + theme(legend.key.size = unit(0.25, 'cm'),
        legend.title = element_text(size=8, face = "bold"),
        legend.text = element_text(size=8),
        axis.title.x=element_blank(),
        axis.title.y=element_text(size = 10),
        axis.text.x = element_text(size = 8, angle = 45, 
                                   hjust = 1, vjust = 1,
                                   face = "bold")) +
        ylab("Relative Abundance") +
        guides(fill = guide_legend(nrow = 30))

 p1
 f1 <- paste("results/final-plots/taxa-bar-plots/taxa-rank-" , x , "_barplot_top20_groupedby_Sample_Type.pdf", sep = "")
 ggsave(f1, device = "pdf")
})
```




# Mean relative abundance table

Described below is how to calculate mean relative abundance across all sampling locations for each taxon/ASV.

Mean relative abundance function

```{r PrevalenceFiltering-23 }
mean_rel_abund = function(physeq.prev, rank = "Species") {

 GPf = tax_glom(physeq.prev, rank, NArm = F) %>% transform_sample_counts(function(x) {x * 100/sum(x)})

 df = data.frame(Family = tax_table(GPf)[,rank], Mean = colMeans(otu_table(GPf)), row.names = NULL)
 df = df[order(-df$Mean),]
 return(df)
}
```

## Calculate for most rankings
```{r}
ranks <- c("Species", "Genus", "Family", "Order","Class", "Phylum")
plots <- lapply(ranks, function(x) {
 mra <- mean_rel_abund(physeq.prev, rank = x)
 fname = paste("results/mean-rel-abund/mean-rel-abund_", x, ".txt", sep="")
 head(mra)
 write.table(mra, file = fname, row.names = FALSE, sep = "\t")
})
```

## Find Genus for known species (manual)

Steps for manually adding Genus to Species, but should find a more automated way in the future
```{r}
GPf = tax_glom(physeq.prev, "Species", NArm = F) %>% transform_sample_counts(function(x) {x * 100/sum(x)})
spec <- c("acnes","pluranimalium","komagatae","massiliensis", "granulosum","gibsonii")

# Get IDs associated with these species
id.list <- tax_table(GPf)[,"Species"][tax_table(GPf)[,"Species"] %in% spec]

# Find IDs and list Genus and Species
tax_table(GPf)[,c("Genus","Species")][row.names(tax_table(GPf)[,"Genus"]) %in% row.names(id.list)]
```



# Beta diversity

Initial beta diversity calculation. Bray Curtis and Weighted UniFrac metrics used for calculating compositional/beta diversity scores, and PCoA ordination used for ordering samples and taxa.

# PCoA plots

## Relative proportion

Transform data to relative proportions (no prior added).

```{r }
physeq.prop <- transform_sample_counts(physeq.prev, function(x) x/sum(x) )
sample_data(physeq.prop)$SampleSums <- sample_sums(physeq.prev)
physeq.active <- physeq.prop
```


# Plotting

PCoA - Bray Curtis
```{r }
finalPhyseq.ord <- ordinate(physeq.active, "PCoA", "bray")
p1 = plot_ordination(physeq.active,
                     finalPhyseq.ord,
                     type="samples",
                     color="Sample_Type",
                     label = "Location",
                     title="Samples") + geom_point(size = 2.5)
p1 + ggtitle("PCoA plot of Bray Curtis distances") 

ggsave("PCoA_BrayCurtis_bySample_Type.pdf",path="results/final-plots", device="pdf")
```


PCoA - Weighted Unifrac
```{r }
finalPhyseq.ord <- ordinate(physeq.prop.1, "PCoA", "wunifrac")
p1 = plot_ordination(physeq.prop.1,
                     finalPhyseq.ord,
                     type="samples",
                     color="Sample_Type",
                     label = "Location",
                     title="Samples") + geom_point(size = 2.5)
p1 + ggtitle("PCoA plot of Bray Curtis distances") 

ggsave("PCoA_WeightedUnifrac_bySample_Type.pdf",path="results/final-plots", device="pdf")
```


Does starting number of sequences affect groupings?
```{r }
p1 <- plot_ordination(physeq.active,
                     finalPhyseq.ord,
                     type="samples",
                     color="input",
                     label="SampleID",
                     title="Samples")
p1
```
No


## PERMANOVA

Let's try PERMANOVA on this using the implementation in `vegan` (`adonis2`).

### Weighted Unifrac metric (phylogenetic)
```{r }
set.seed(12345)
finalPhyseq.meta <- as(sample_data(physeq.active), "data.frame")
finalPhyseq.prop.dist.bc <- phyloseq::distance(physeq.active, method = "wunifrac")
```

Simple models:
```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Location,
       data = finalPhyseq.meta)
```

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Sample_Type ,
       data = finalPhyseq.meta) 
```

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Simple_Type,
       data = finalPhyseq.meta)
```


Complex models
```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Simple_Type * Horse ,
       data = finalPhyseq.meta) 
```

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Sample_Type * Horse ,
       data = finalPhyseq.meta) 
```

Check for significance in differences between group dispersion.
```{r }
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Location)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Sample_Type)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Sex)
permutest(beta)
```



### Bray Curtis metric (non-phylogenetic)
```{r }
set.seed(12345)
finalPhyseq.meta <- as(sample_data(physeq.active), "data.frame")
finalPhyseq.prop.dist.bc <- phyloseq::distance(physeq.active, method = "bray")
```

Simple models:
```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Location,
       data = finalPhyseq.meta)
```

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Sample_Type ,
       data = finalPhyseq.meta)
```

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Simple_Type ,
       data = finalPhyseq.meta)
```


Complex models:
```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Simple_Type * Horse ,
       data = finalPhyseq.meta)
```

```{r}
adonis2(finalPhyseq.prop.dist.bc ~ Sample_Type * Horse ,
       data = finalPhyseq.meta)
```

Check for significance in differences between group dispersion.
```{r }
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Sample_Type)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Location)
permutest(beta)
beta <- betadisper(finalPhyseq.prop.dist.bc, finalPhyseq.meta$Sex)
permutest(beta)
```



## Differential abundance analysis

Run DESeq2 for Location:
```{r }
library(DESeq2)

targets <- sample_data(physeq.prev)

design <- model.matrix(~ Location, data = as(targets, "data.frame"))

finalPhyseq.adds = phyloseq_to_deseq2(physeq.prev, ~ Location)

finalPhyseq.adds = DESeq(finalPhyseq.adds, 
                         test="Wald", 
                         fitType="local",
                         sfType = "poscounts",
                         quiet = TRUE
                         )
```

Custom function for pulling out contrasts:
```{r }
generateContrastResults <- function(deseq, contrast, physeq, file = "results.txt") {
  res = results(deseq, 
              cooksCutoff = FALSE, 
              contrast = contrast,
              test = "Wald"
              )
  res = cbind(as(res, "data.frame"), as(tax_table(physeq)[rownames(res), ], "matrix"))
  
  write.table(res, file, row.names = TRUE, col.names = NA, sep = "\t")
  return(res)
}

plotDESeq2ResGenus <- function(res) {
  sigtab <- res[which(res$padj < 0.05), ]
  scale_fill_discrete <- function(palname = "Set1", ...) {
      scale_fill_brewer(palette = palname, ...)
  }
  
  x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
  
  # Genus order
  x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))
  p <- ggplot(sigtab, aes(x=Genus, y=log2FoldChange, color=Phylum)) + geom_point(size=6) +
    theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust=0.5, face = 'italic'),
          legend.text = element_text(face = 'italic'))
  return(p)
}

plotDESeq2ResFamily <- function(res) {
  sigtab <- res[which(res$padj < 0.05), ]
  scale_fill_discrete <- function(palname = "Set1", ...) {
      scale_fill_brewer(palette = palname, ...)
  }
  
  x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
  
  # Family order
  x = tapply(sigtab$log2FoldChange, sigtab$Family, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Family = factor(as.character(sigtab$Family), levels=names(x))
  p <- ggplot(sigtab, aes(x=Family, y=log2FoldChange, color=Phylum)) + geom_point(size=6) +
    theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust=0.5, face = 'italic'),
          legend.text = element_text(face = 'italic'))
  return(p)
}

plotDESeq2ResSpecies <- function(res) {
  sigtab <- res[which(res$padj < 0.05), ]
  scale_fill_discrete <- function(palname = "Set1", ...) {
      scale_fill_brewer(palette = palname, ...)
  }
  
  x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
  
  # Genus + Species order
  sigtab$GeneSpecies <- paste(sigtab$Genus,sigtab$Species)
  x = tapply(sigtab$log2FoldChange, sigtab$GeneSpecies, function(x) max(x))
  x = sort(x, TRUE)
  sigtab$GeneSpecies = factor(as.character(sigtab$GeneSpecies), levels=names(x))
  p <- ggplot(sigtab, aes(x=GeneSpecies, y=log2FoldChange, color=Phylum)) + geom_point(size=6) +
    theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust=0.5, face = 'italic'),
          legend.text = element_text(face = 'italic'))
  return(p)
}
```


Loop to save tables and images for all the different pairwise contrasts of Location grouping.
```{r}
n.all <- sample_data(physeq.prev)$Location %>% levels()
for(x in 1:8){
  for(y in 1:8){
    if(x < y){  # Ignore useless and redundant files
      res.test <- generateContrastResults(deseq = finalPhyseq.adds, 
                                contrast = c("Location", 
                                             n.all[x],  # num
                                             n.all[y]), # denom
                                physeq = physeq.prev,
                                file = paste("results/diff-abund/location/tables/Diff-Abund_", n.all[x], "-vs-", n.all[y], ".txt", sep="")
      )
      plotDESeq2ResFamily(res.test)
      f <- paste("Diff-Abund_Family_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/location", device = "pdf")
      plotDESeq2ResGenus(res.test)
      f <- paste("Diff-Abund_Genus_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/location", device = "pdf")
      plotDESeq2ResSpecies(res.test)
      f <- paste("Diff-Abund_Species_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/location", device = "pdf")
    }
  }
}
```


DESeq2 for Sample_Type
```{r }
targets <- sample_data(physeq.prev)

design <- model.matrix(~ Sample_Type, data = as(targets, "data.frame"))

finalPhyseq.adds = phyloseq_to_deseq2(physeq.prev, ~ Sample_Type)

finalPhyseq.adds = DESeq(finalPhyseq.adds, 
                         test="Wald", 
                         fitType="local",
                         sfType = "poscounts",
                         quiet = TRUE
                         )
```

Loop to save tables and images for all the different pairwise contrasts of Sample_Type grouping.
```{r}
n.all <- sample_data(physeq.prev)$Sample_Type %>% levels()
for(x in 1:3){
  for(y in 1:3){
    if(x < y){  # Ignore useless and redundant files
      res.test <- generateContrastResults(deseq = finalPhyseq.adds, 
                                contrast = c("Sample_Type", 
                                             n.all[x],  # num
                                             n.all[y]), # denom
                                physeq = physeq.prev,
                                file = paste("results/diff-abund/sample_type/tables/Diff-Abund_", n.all[x], "-vs-", n.all[y], ".txt", sep="")
      )
      plotDESeq2ResFamily(res.test)
      f <- paste("Diff-Abund_Family_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/sample_type", device = "pdf")
      plotDESeq2ResGenus(res.test)
      f <- paste("Diff-Abund_Genus_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/sample_type", device = "pdf")
      plotDESeq2ResSpecies(res.test)
      f <- paste("Diff-Abund_Species_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/sample_type", device = "pdf")
    }
  }
}
```

DESeq2 for Simple_Type (TTA+NPL vs BAL)
```{r }
targets <- sample_data(physeq.prev)

design <- model.matrix(~ Simple_Type, data = as(targets, "data.frame"))

finalPhyseq.adds = phyloseq_to_deseq2(physeq.prev, ~ Simple_Type)

finalPhyseq.adds = DESeq(finalPhyseq.adds, 
                         test="Wald", 
                         fitType="local",
                         sfType = "poscounts",
                         quiet = TRUE
                         )
```

Loop to save tables and images for all the different pairwise contrasts of Simple_Type grouping.
```{r}
n.all <- sample_data(physeq.prev)$Simple_Type %>% levels()
for(x in 1:2){
  for(y in 1:2){
    if(x < y){  # Ignore useless and redundant files
      res.test <- generateContrastResults(deseq = finalPhyseq.adds, 
                                contrast = c("Simple_Type", 
                                             n.all[x],  # num
                                             n.all[y]), # denom
                                physeq = physeq.prev,
                                file = paste("results/diff-abund/simple_type/tables/Diff-Abund_", n.all[x], "-vs-", n.all[y], ".txt", sep="")
      )
      plotDESeq2ResFamily(res.test)
      f <- paste("Diff-Abund_Family_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/simple_type", device = "pdf")
      plotDESeq2ResGenus(res.test)
      f <- paste("Diff-Abund_Genus_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/simple_type", device = "pdf")
      plotDESeq2ResSpecies(res.test)
      f <- paste("Diff-Abund_Species_", n.all[x], "-vs-", n.all[y], ".pdf", sep="")
      ggsave(f, path = "results/diff-abund/simple_type", device = "pdf")
    }
  }
}
```




# Heatmaps

## Add extra label column
```{r}
sample_data(physeq.prev)$label <- paste(sample_data(physeq.prev)$Horse, sample_data(physeq.prev)$Sex, sample_data(physeq.prev)$Location, sep = ".")
physeq.active <- physeq.prev

```

## Genus-level heatmaps
```{r}
#Agglomerate taxa and species level to remove redundancy
physeq.heat.glom <- tax_glom(physeq.active, taxrank = "Genus", NArm = FALSE)

# Genus is not NA
no.na <- !is.na(tax_table(physeq.heat.glom)[,"Genus"])

#Genus level in beneficial has a couple NAs that need to be renamed to Family
tax_table(physeq.heat.glom)[!no.na][,"Genus"] = paste("[Family]", tax_table(physeq.heat.glom)[!no.na][,"Family"])
```

Bray-Curtis heatmap
```{r}
p <- plot_heatmap(physeq.heat.glom,
                  method = "PCoA",
                  distance = "bray",
                  taxa.label = "Genus",
                  sample.label = "label",
                  sample.order = "Sample_Type",
                  trans = log_trans(2),
                  title = "PCoA Bray-Curtis Heatmap")
p + theme(axis.text.y = element_text(face = 'italic', size = 8), axis.text.x = element_text(size = 8)) 

ggsave("bray-curtis-genus-level-heatmap-orderedBySampleType.pdf", path = "results/heatmaps", device = "pdf")
```

Weighted Unifrac heatmap
```{r}
p <- plot_heatmap(physeq.heat.glom,
                  method = "PCoA",
                  distance = "wunifrac",
                  taxa.label = "Genus",
                  sample.label = "label",
                  sample.order = "Sample_Type",
                  trans = log_trans(2),
                  title = "PCoA Weighted Unifrac Heatmap")
p + theme(axis.text.y = element_text(face = 'italic', size = 8), axis.text.x = element_text(size = 8)) 

ggsave("weighted-unifrac-genus-level-heatmap-orderedBySampleType.pdf", path = "results/heatmaps", device = "pdf")
```



# Species-level heatmaps
```{r}
#Agglomerate taxa and species level to remove redundancy
physeq.heat.glom <- tax_glom(physeq.active, taxrank = "Species", NArm = FALSE)

# Genus is not NA
no.na <- !is.na(tax_table(physeq.heat.glom)[,"Genus"])

#Genus level has some NAs that need to be renamed
tax_table(physeq.heat.glom)[!no.na][,"Genus"] = paste("[Family]", tax_table(physeq.heat.glom)[!no.na][,"Family"])

#Replace "Unclassified" and NA species w/ "sp."
tax_table(physeq.heat.glom)[,"Species"][tax_table(physeq.heat.glom)[,"Species"] == "Unclassified"] <- "sp."
tax_table(physeq.heat.glom)[,"Species"][is.na(tax_table(physeq.heat.glom)[,"Species"])] <- "sp."

# Replace Species with full name
tax_table(physeq.heat.glom)[,"Species"] = paste(tax_table(physeq.heat.glom)[,"Genus"], tax_table(physeq.heat.glom)[,"Species"])
```

Bray-Curtis heatmap
```{r}
p <- plot_heatmap(physeq.heat.glom,
                  method = "PCoA",
                  distance = "bray",
                  taxa.label = "Species",
                  sample.label = "label",
                  sample.order = "Location",
                  trans = log_trans(2),
                  title = "PCoA Bray-Curtis Heatmap")
p + theme(axis.text.y = element_text(face = 'italic', size = 8), axis.text.x = element_text(size = 8)) 

ggsave("bray-curtis-species-level-heatmap-orderedByLocation.pdf", path = "results/heatmaps", device = "pdf")
```

Weighted Unifrac heatmap
```{r}
p <- plot_heatmap(physeq.heat.glom,
                  method = "PCoA",
                  distance = "wunifrac",
                  taxa.label = "Species",
                  sample.label = "label",
                  sample.order = "Location",
                  trans = log_trans(2),
                  title = "PCoA Weighted Unifrac Heatmap")
p + theme(axis.text.y = element_text(face = 'italic', size = 8), axis.text.x = element_text(size = 8)) 

ggsave("weighted-unifrac-species-level-heatmap-orderedByLocation.pdf", path = "results/heatmaps", device = "pdf")
```




# Save

```{r }
saveRDS(physeq.prop, file = "results/phyloseq-prev-prop.RDS")
```

# Session

```{r }
sessionInfo()
```
R version 4.3.0 Patched (2023-06-03 r84490)
Platform: aarch64-apple-darwin20 (64-bit)
Running under: macOS Ventura 13.5.1

Matrix products: default
BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib 
LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

time zone: America/Chicago
tzcode source: internal

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] microViz_0.11.0              DESeq2_1.40.1                SummarizedExperiment_1.30.1  MatrixGenerics_1.12.0       
 [5] matrixStats_1.0.0            GenomicRanges_1.52.0         phyloseq.extended_0.0.0.9000 plotly_4.10.2               
 [9] picante_1.8.2                dada2_1.28.0                 Rcpp_1.0.10                  readxl_1.4.2                
[13] gridExtra_2.3                reshape2_1.4.4               scales_1.2.1                 exactRankTests_0.8-35       
[17] Biostrings_2.68.1            GenomeInfoDb_1.36.0          XVector_0.40.0               IRanges_2.34.0              
[21] S4Vectors_0.38.1             ranacapa_0.1.0               microbiome_1.22.0            plotly.microbiome_0.0.9003  
[25] devtools_2.4.5               usethis_2.2.0                lsmeans_2.30-0               emmeans_1.8.8               
[29] nlme_3.1-162                 lmerTest_3.1-3               lme4_1.1-33                  WGCNA_1.72-1                
[33] fastcluster_1.2.3            dynamicTreeCut_1.63-1        mixOmics_6.24.0              MASS_7.3-60                 
[37] ggpubr_0.6.0                 vegan_2.6-4                  lattice_0.21-8               permute_0.9-7               
[41] ggdendro_0.1.23              biomformat_1.28.0            ape_5.7-1                    metagenomeSeq_1.42.0        
[45] RColorBrewer_1.1-3           glmnet_4.1-8                 Matrix_1.5-4.1               limma_3.56.2                
[49] Biobase_2.60.0               BiocGenerics_0.46.0          phyloseq_1.44.0              lubridate_1.9.2             
[53] forcats_1.0.0                stringr_1.5.0                dplyr_1.1.2                  purrr_1.0.1                 
[57] readr_2.1.4                  tidyr_1.3.0                  tibble_3.2.1                 ggplot2_3.4.2               
[61] tidyverse_2.0.0              knitr_1.43                   phyloseq_1.44.0                 

loaded via a namespace (and not attached):
  [1] fs_1.6.2                    bitops_1.0-7                httr_1.4.6                  doParallel_1.0.17          
  [5] numDeriv_2016.8-1.1         profvis_0.3.8               tools_4.3.0                 backports_1.4.1            
  [9] utf8_1.2.3                  R6_2.5.1                    lazyeval_0.2.2              mgcv_1.8-42                
 [13] rhdf5filters_1.12.1         urlchecker_1.0.1            withr_2.5.0                 prettyunits_1.1.1          
 [17] preprocessCore_1.62.1       textshaping_0.3.6           cli_3.6.1                   TSP_1.2-4                  
 [21] labeling_0.4.2              mvtnorm_1.2-3               dittoSeq_1.12.0             ggridges_0.5.4             
 [25] systemfonts_1.0.4           Rsamtools_2.16.0            foreign_0.8-84              sessioninfo_1.2.2          
 [29] rstudioapi_0.14             impute_1.74.1               RSQLite_2.3.1               generics_0.1.3             
 [33] shape_1.4.6                 hwriter_1.3.2.1             crosstalk_1.2.0             vroom_1.6.3                
 [37] gtools_3.9.4                car_3.1-2                   GO.db_3.17.0                interp_1.1-4               
 [41] fansi_1.0.4                 abind_1.4-5                 lifecycle_1.0.3             yaml_2.3.7                 
 [45] carData_3.0-5               Rtsne_0.16                  gplots_3.1.3                rhdf5_2.44.0               
 [49] grid_4.3.0                  blob_1.2.4                  promises_1.2.0.1            crayon_1.5.2               
 [53] miniUI_0.1.1.1              cowplot_1.1.1               KEGGREST_1.40.0             pillar_1.9.0               
 [57] boot_1.3-28.1               estimability_1.4.1          corpcor_1.6.10              codetools_0.2-19           
 [61] glue_1.6.2                  ShortRead_1.58.0            data.table_1.14.8           remotes_2.4.2              
 [65] vctrs_0.6.2                 png_0.1-8                   testthat_3.1.8              cellranger_1.1.0           
 [69] gtable_0.3.3                cachem_1.0.8                xfun_0.39                   S4Arrays_1.0.4             
 [73] mime_0.12                   survival_3.5-5              seriation_1.4.2             pheatmap_1.0.12            
 [77] SingleCellExperiment_1.22.0 iterators_1.0.14            ellipsis_0.3.2              bit64_4.0.5                
 [81] rprojroot_2.0.3             KernSmooth_2.23-21          rpart_4.1.19                colorspace_2.1-0           
 [85] DBI_1.1.3                   Hmisc_5.1-0                 nnet_7.3-19                 ade4_1.7-22                
 [89] NADA_1.6-1.1                tidyselect_1.2.0            processx_3.8.1              bit_4.0.5                  
 [93] compiler_4.3.0              htmlTable_2.4.1             desc_1.4.2                  DelayedArray_0.26.3        
 [97] checkmate_2.2.0             caTools_1.18.2              callr_3.7.3                 digest_0.6.31              
[101] minqa_1.2.5                 rmarkdown_2.22              ca_0.71.1                   jpeg_0.1-10                
[105] htmltools_0.5.5             pkgconfig_2.0.3             base64enc_0.1-3             fastmap_1.1.1              
[109] rlang_1.1.1                 htmlwidgets_1.6.2           shiny_1.7.4                 zCompositions_1.4.0-1      
[113] farver_2.1.1                jsonlite_1.8.5              BiocParallel_1.34.2         RCurl_1.98-1.12            
[117] magrittr_2.0.3              Formula_1.2-5               GenomeInfoDbData_1.2.10     Rhdf5lib_1.22.0            
[121] munsell_0.5.0               viridis_0.6.3               stringi_1.7.12              brio_1.1.3                 
[125] zlibbioc_1.46.0             plyr_1.8.8                  pkgbuild_1.4.0              ggrepel_0.9.3              
[129] deldir_1.0-9                splines_4.3.0               multtest_2.56.0             hms_1.1.3                  
[133] locfit_1.5-9.8              ps_1.7.5                    igraph_1.4.3                ggsignif_0.6.4             
[137] Wrench_1.18.0               pkgload_1.3.2               evaluate_0.21               latticeExtra_0.6-30        
[141] BiocManager_1.30.20         RcppParallel_5.1.7          nloptr_2.0.3                tzdb_0.4.0                 
[145] foreach_1.5.2               httpuv_1.6.11               broom_1.0.4                 xtable_1.8-4               
[149] RSpectra_0.16-1             rstatix_0.7.2               later_1.3.1                 ragg_1.2.5                 
[153] viridisLite_0.4.2           truncnorm_1.0-9             rARPACK_0.11-0              registry_0.5-1             
[157] GenomicAlignments_1.36.0    memoise_2.0.1               AnnotationDbi_1.62.1        ellipse_0.4.5              
[161] cluster_2.1.4               timechange_0.2.0           
